diff -ur a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
--- a/dlls/bcrypt/bcrypt_main.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/bcrypt/bcrypt_main.c	2017-07-17 13:28:50.647413482 +0200
@@ -903,16 +903,24 @@
     switch (key->alg_id)
     {
     case ALG_ID_AES:
-        WARN( "handle block size\n" );
+        if (key->secret_len != 16 && key->secret_len != 32)
+        {
+            FIXME( "bad secret_len %d for AES\n", key->secret_len );
+            return GNUTLS_CIPHER_UNKNOWN;
+        }
         switch (key->mode)
         {
-            case MODE_ID_GCM: return GNUTLS_CIPHER_AES_128_GCM;
-            case MODE_ID_ECB: /* can be emulated with CBC + empty IV */
-            case MODE_ID_CBC:
-            default:          return GNUTLS_CIPHER_AES_128_CBC;
+        case MODE_ID_GCM:
+            return key->secret_len == 16 ? GNUTLS_CIPHER_AES_128_GCM : GNUTLS_CIPHER_AES_256_GCM;
+        case MODE_ID_ECB: /* can be emulated with CBC + empty IV */
+        case MODE_ID_CBC:
+            return key->secret_len == 16 ? GNUTLS_CIPHER_AES_128_CBC : GNUTLS_CIPHER_AES_256_CBC;
+        default:
+            FIXME( "AES with mode %u not supported\n", key->mode );
+            return GNUTLS_CIPHER_UNKNOWN;
         }
     default:
-        FIXME( "algorithm %u not supported\n", key->alg_id );
+        FIXME( "algorithm %u with mode %u not supported\n", key->alg_id, key->mode );
         return GNUTLS_CIPHER_UNKNOWN;
     }
 }
@@ -1331,6 +1339,41 @@
     return status;
 }
 
+NTSTATUS WINAPI BCryptImportKey(BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_HANDLE hImportKey,
+                                const WCHAR *blobtype, BCRYPT_KEY_HANDLE *handle, UCHAR *object,
+                                ULONG object_len, UCHAR *pbInput, ULONG cbInput, ULONG flags)
+{
+    struct algorithm *alg = algorithm;
+    struct key *key;
+    NTSTATUS status;
+
+    FIXME("%p, %p, %s, %p, %p, %08x, %p, %08x, %08x - semistub\n", alg, hImportKey,
+          wine_dbgstr_w(blobtype), handle, object, object_len, pbInput, cbInput, flags);
+
+	if (!strcmpW(blobtype, BCRYPT_KEY_DATA_BLOB)) {
+		struct _BCRYPT_KEY_DATA_BLOB_HEADER *kdbh = (BCRYPT_KEY_DATA_BLOB_HEADER*)pbInput;
+
+		if (!(key = HeapAlloc( GetProcessHeap(), 0, sizeof(*key) )))
+		{
+		    *handle = NULL;
+		    return STATUS_NO_MEMORY;
+		}
+		key->hdr.magic = MAGIC_KEY;
+
+		if ((status = key_init( key, alg, pbInput + sizeof(BCRYPT_KEY_DATA_BLOB_HEADER), kdbh->cbKeyData )))
+		{
+		    HeapFree( GetProcessHeap(), 0, key );
+		    *handle = NULL;
+		    return status;
+		}
+
+		*handle = key;
+		return STATUS_SUCCESS;
+	} else {
+		return STATUS_NOT_IMPLEMENTED;
+	}
+}
+
 BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
 {
     switch (reason)
diff -ur a/dlls/bcrypt/bcrypt.spec b/dlls/bcrypt/bcrypt.spec
--- a/dlls/bcrypt/bcrypt.spec	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/bcrypt/bcrypt.spec	2017-07-17 13:28:50.647413482 +0200
@@ -31,7 +31,7 @@
 @ stdcall BCryptGetProperty(ptr wstr ptr long ptr long)
 @ stdcall BCryptHash(ptr ptr long ptr long ptr long)
 @ stdcall BCryptHashData(ptr ptr long long)
-@ stub BCryptImportKey
+@ stdcall BCryptImportKey(ptr ptr wstr ptr ptr long ptr long long)
 @ stub BCryptImportKeyPair
 @ stdcall BCryptOpenAlgorithmProvider(ptr wstr wstr long)
 @ stub BCryptQueryContextConfiguration
diff -ur a/dlls/d3d10core/tests/device.c b/dlls/d3d10core/tests/device.c
--- a/dlls/d3d10core/tests/device.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/d3d10core/tests/device.c	2017-07-17 13:28:50.697413075 +0200
@@ -11868,6 +11868,250 @@
     release_test_context(&test_context);
 }
 
+static void test_nointerpolation(void)
+{
+    HRESULT hr;
+    ID3D10Buffer *vb;
+    ID3D10Device *device;
+    ID3D10InputLayout *layout;
+    ID3D10PixelShader *ps;
+    ID3D10VertexShader *vs;
+    UINT stride, offset;
+    struct d3d10core_test_context test_context;
+
+    static const DWORD vs_code[] =
+    {
+#if 0
+    struct vertex_out
+    {
+        float4 pos : SV_POSITION;
+        nointerpolation float4 color : COLOR0;
+    };
+
+    void main(float4 pos : POSITION, out vertex_out vo)
+    {
+        if (pos.x < 0)
+            vo.color = float4(0.0f, 0.0f, 1.0f, 1.0f);
+        else
+            vo.color = float4(1.0f, 0.0f, 0.0f, 1.0f);
+        vo.pos = pos;
+    }
+#endif
+        0x43425844, 0x20DAAA2B, 0x0D32B307, 0x886028DE, 0xD63037F3, 0x00000001, 0x00000164, 0x00000003,
+        0x0000002C, 0x00000060, 0x000000B4, 0x4E475349, 0x0000002C, 0x00000001, 0x00000008, 0x00000020,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000F0F, 0x49534F50, 0x4E4F4954, 0xABABAB00,
+        0x4E47534F, 0x0000004C, 0x00000002, 0x00000008, 0x00000038, 0x00000000, 0x00000001, 0x00000003,
+        0x00000000, 0x0000000F, 0x00000044, 0x00000000, 0x00000000, 0x00000003, 0x00000001, 0x0000000F,
+        0x505F5653, 0x5449534F, 0x004E4F49, 0x4F4C4F43, 0xABAB0052, 0x52444853, 0x000000A8, 0x00010040,
+        0x0000002A, 0x0300005F, 0x001010F2, 0x00000000, 0x04000067, 0x001020F2, 0x00000000, 0x00000001,
+        0x03000065, 0x001020F2, 0x00000001, 0x02000068, 0x00000001, 0x05000036, 0x001020F2, 0x00000000,
+        0x00101E46, 0x00000000, 0x07000031, 0x00100012, 0x00000000, 0x0010100A, 0x00000000, 0x00004001,
+        0x00000000, 0x0F000037, 0x001020F2, 0x00000001, 0x00100006, 0x00000000, 0x00004002, 0x00000000,
+        0x00000000, 0x3F800000, 0x3F800000, 0x00004002, 0x3F800000, 0x00000000, 0x00000000, 0x3F800000,
+        0x0100003E
+    };
+
+    static const DWORD ps_code[] =
+    {
+#if 0
+    struct vertex_out
+    {
+        float4 pos : SV_POSITION;
+        nointerpolation float4 color : COLOR0;
+    };
+
+    float4 main(vertex_out vo) : SV_TARGET
+    {
+        return vo.color;
+    }
+#endif
+        0x43425844, 0x33D9B6B6, 0xB32F761F, 0xA3EBDFC9, 0xE2C9CDBD, 0x00000001, 0x000000F4, 0x00000003,
+        0x0000002C, 0x00000080, 0x000000B4, 0x4E475349, 0x0000004C, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000F, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000F0F, 0x505F5653, 0x5449534F, 0x004E4F49, 0x4F4C4F43, 0xABAB0052,
+        0x4E47534F, 0x0000002C, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003,
+        0x00000000, 0x0000000F, 0x545F5653, 0x45475241, 0xABAB0054, 0x52444853, 0x00000038, 0x00000040,
+        0x0000000E, 0x03000862, 0x001010F2, 0x00000001, 0x03000065, 0x001020F2, 0x00000000, 0x05000036,
+        0x001020F2, 0x00000000, 0x00101E46, 0x00000001, 0x0100003E
+    };
+
+    static const D3D10_INPUT_ELEMENT_DESC layout_desc[] =
+    {
+        { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 },
+    };
+
+    static const struct vec2 quad[] =
+    {
+        { -1.0f, -1.0f },
+        { -1.0f,  1.0f },
+        {  1.0f, -1.0f },
+        {  1.0f,  1.0f },
+    };
+
+    if (!init_test_context(&test_context))
+        return;
+
+    device = test_context.device;
+
+    hr = ID3D10Device_CreateInputLayout(device, layout_desc, 1, vs_code, sizeof(vs_code), &layout);
+    ok(SUCCEEDED(hr), "Failed to create input layout, hr %#x.\n", hr);
+    vb = create_buffer(device, D3D10_BIND_VERTEX_BUFFER, sizeof(quad), quad);
+    hr = ID3D10Device_CreateVertexShader(device, vs_code, sizeof(vs_code), &vs);
+    ok(SUCCEEDED(hr), "Failed to create vertex shader, hr %#x.\n", hr);
+    hr = ID3D10Device_CreatePixelShader(device, ps_code, sizeof(ps_code), &ps);
+    ok(SUCCEEDED(hr), "Failed to create pixel shader, hr %#x.\n", hr);
+
+    ID3D10Device_IASetInputLayout(device, layout);
+    ID3D10Device_IASetPrimitiveTopology(device, D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+    stride = sizeof(quad[0]);
+    offset = 0;
+    ID3D10Device_IASetVertexBuffers(device, 0, 1, &vb, &stride, &offset);
+    ID3D10Device_VSSetShader(device, vs);
+    ID3D10Device_PSSetShader(device, ps);
+
+    ID3D10Device_Draw(device, 4, 0);
+    check_texture_color(test_context.backbuffer, 0xffff0000, 1);
+
+    ID3D10Buffer_Release(vb);
+    ID3D10InputLayout_Release(layout);
+    ID3D10PixelShader_Release(ps);
+    ID3D10VertexShader_Release(vs);
+    release_test_context(&test_context);
+}
+
+static void test_tbuffer(void)
+{
+    D3D10_SHADER_RESOURCE_VIEW_DESC view_desc;
+    HRESULT hr;
+    ID3D10Buffer *vb, *tb;
+    ID3D10Device *device;
+    ID3D10InputLayout *layout;
+    ID3D10PixelShader *ps;
+    ID3D10ShaderResourceView *tb_view;
+    ID3D10VertexShader *vs;
+    UINT stride, offset;
+    struct d3d10core_test_context test_context;
+
+    static const DWORD vs_code[] =
+    {
+#if 0
+    float4 main(float4 pos : POSITION) : SV_POSITION
+    {
+        return pos;
+    }
+#endif
+        0x43425844, 0x77f030d7, 0x18f13b6b, 0x47fff01f, 0x97ead6d3, 0x00000001, 0x000001b4, 0x00000005,
+        0x00000034, 0x0000008c, 0x000000c0, 0x000000f4, 0x00000138, 0x46454452, 0x00000050, 0x00000000,
+        0x00000000, 0x00000000, 0x0000001c, 0xfffe0400, 0x00000100, 0x0000001c, 0x7263694d, 0x666f736f,
+        0x52282074, 0x4c482029, 0x53204c53, 0x65646168, 0x6f432072, 0x6c69706d, 0x36207265, 0x392e332e,
+        0x2e303036, 0x38333631, 0xabab0034, 0x4e475349, 0x0000002c, 0x00000001, 0x00000008, 0x00000020,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000f0f, 0x49534f50, 0x4e4f4954, 0xababab00,
+        0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000001, 0x00000003,
+        0x00000000, 0x0000000f, 0x505f5653, 0x5449534f, 0x004e4f49, 0x52444853, 0x0000003c, 0x00010040,
+        0x0000000f, 0x0300005f, 0x001010f2, 0x00000000, 0x04000067, 0x001020f2, 0x00000000, 0x00000001,
+        0x05000036, 0x001020f2, 0x00000000, 0x00101e46, 0x00000000, 0x0100003e, 0x54415453, 0x00000074,
+        0x00000002, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+    };
+
+    static const DWORD ps_code[] =
+    {
+#if 0
+    tbuffer buf : register(t0)
+    {
+        float4 color;
+    };
+
+    float4 main() : SV_TARGET
+    {
+        return color;
+    }
+#endif
+        0x43425844, 0x921b0266, 0x0d6e2f9c, 0x7e3b529c, 0xab5ab054, 0x00000001, 0x0000022c, 0x00000005,
+        0x00000034, 0x000000f8, 0x00000108, 0x0000013c, 0x000001b0, 0x46454452, 0x000000bc, 0x00000001,
+        0x00000040, 0x00000001, 0x0000001c, 0xffff0400, 0x00000100, 0x00000088, 0x0000003c, 0x00000001,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00667562, 0x0000003c,
+        0x00000001, 0x00000058, 0x00000010, 0x00000000, 0x00000001, 0x00000070, 0x00000000, 0x00000010,
+        0x00000002, 0x00000078, 0x00000000, 0x6f6c6f63, 0xabab0072, 0x00030001, 0x00040001, 0x00000000,
+        0x00000000, 0x7263694d, 0x666f736f, 0x52282074, 0x4c482029, 0x53204c53, 0x65646168, 0x6f432072,
+        0x6c69706d, 0x36207265, 0x392e332e, 0x2e303036, 0x38333631, 0xabab0034, 0x4e475349, 0x00000008,
+        0x00000000, 0x00000008, 0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000,
+        0x00000000, 0x00000003, 0x00000000, 0x0000000f, 0x545f5653, 0x45475241, 0xabab0054, 0x52444853,
+        0x0000006c, 0x00000040, 0x0000001b, 0x04000858, 0x00107000, 0x00000000, 0x00006666, 0x03000065,
+        0x001020f2, 0x00000000, 0x02000068, 0x00000001, 0x0a00002d, 0x001000f2, 0x00000000, 0x00004002,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00107e46, 0x00000000, 0x05000036, 0x001020f2,
+        0x00000000, 0x00100e46, 0x00000000, 0x0100003e, 0x54415453, 0x00000074, 0x00000003, 0x00000001,
+        0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000,
+        0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000
+    };
+
+    static const D3D10_INPUT_ELEMENT_DESC layout_desc[] =
+    {
+        { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 },
+    };
+
+    static const struct vec2 quad[] =
+    {
+        { -1.0f, -1.0f },
+        { -1.0f,  1.0f },
+        { 1.0f, -1.0f },
+        { 1.0f,  1.0f },
+    };
+
+    static const struct vec4 color[] =
+    {
+        { 1.0f, 1.0f, 0.0f, 1.0f },
+    };
+    static const float red[] = {1.0f, 0.0f, 0.0f, 1.0f};
+
+    if (!init_test_context(&test_context))
+        return;
+
+    device = test_context.device;
+    ID3D10Device_ClearRenderTargetView(device, test_context.backbuffer_rtv, red);
+
+    hr = ID3D10Device_CreateInputLayout(device, layout_desc, 1, vs_code, sizeof(vs_code), &layout);
+    ok(SUCCEEDED(hr), "Failed to create input layout, hr %#x.\n", hr);
+    vb = create_buffer(device, D3D10_BIND_VERTEX_BUFFER, sizeof(quad), quad);
+    hr = ID3D10Device_CreateVertexShader(device, vs_code, sizeof(vs_code), &vs);
+    ok(SUCCEEDED(hr), "Failed to create vertex shader, hr %#x.\n", hr);
+    hr = ID3D10Device_CreatePixelShader(device, ps_code, sizeof(ps_code), &ps);
+    ok(SUCCEEDED(hr), "Failed to create pixel shader, hr %#x.\n", hr);
+
+    tb = create_buffer(device, D3D10_BIND_SHADER_RESOURCE, sizeof(color), color);
+    view_desc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
+    view_desc.ViewDimension = D3D10_SRV_DIMENSION_BUFFER;
+    view_desc.Buffer.ElementOffset = 0;
+    view_desc.Buffer.ElementWidth = 1;
+    hr = ID3D10Device_CreateShaderResourceView(device, (ID3D10Resource*)tb, &view_desc, &tb_view);
+    ok(SUCCEEDED(hr), "Failed to create texture buffer view, hr %#x.\n", hr);
+
+    ID3D10Device_IASetInputLayout(device, layout);
+    ID3D10Device_IASetPrimitiveTopology(device, D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+    stride = sizeof(quad[0]);
+    offset = 0;
+    ID3D10Device_IASetVertexBuffers(device, 0, 1, &vb, &stride, &offset);
+    ID3D10Device_VSSetShader(device, vs);
+    ID3D10Device_PSSetShader(device, ps);
+
+    ID3D10Device_PSSetShaderResources(device, 0, 1, &tb_view);
+
+    ID3D10Device_Draw(device, 4, 0);
+    check_texture_color(test_context.backbuffer, 0xff00ffff, 1);
+
+    ID3D10ShaderResourceView_Release(tb_view);
+    ID3D10Buffer_Release(tb);
+    ID3D10Buffer_Release(vb);
+    ID3D10InputLayout_Release(layout);
+    ID3D10PixelShader_Release(ps);
+    ID3D10VertexShader_Release(vs);
+    release_test_context(&test_context);
+}
+
 static void test_geometry_shader(void)
 {
     static const struct
@@ -12642,6 +12886,8 @@
     test_primitive_restart();
     test_resinfo_instruction();
     test_render_target_device_mismatch();
+    test_nointerpolation();
+    test_tbuffer();
     test_buffer_srv();
     test_geometry_shader();
     test_stream_output();
diff -ur a/dlls/d3d11/tests/d3d11.c b/dlls/d3d11/tests/d3d11.c
--- a/dlls/d3d11/tests/d3d11.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/d3d11/tests/d3d11.c	2017-07-17 13:28:50.700746380 +0200
@@ -19151,6 +19151,399 @@
     release_test_context(&test_context);
 }
 
+static void test_nointerpolation(void)
+{
+    HRESULT hr;
+    ID3D11Buffer *vb;
+    ID3D11Device *device;
+    ID3D11DeviceContext *context;
+    ID3D11InputLayout *layout;
+    ID3D11PixelShader *ps;
+    ID3D11VertexShader *vs;
+    UINT stride, offset;
+    struct d3d11_test_context test_context;
+
+    static const DWORD vs_code[] =
+    {
+#if 0
+    struct vertex_out
+    {
+        float4 pos : SV_POSITION;
+        nointerpolation float4 color : COLOR0;
+    };
+
+    void main(float4 pos : POSITION, out vertex_out vo)
+    {
+        if (pos.x < 0)
+            vo.color = float4(0.0f, 0.0f, 1.0f, 1.0f);
+        else
+            vo.color = float4(1.0f, 0.0f, 0.0f, 1.0f);
+        vo.pos = pos;
+    }
+#endif
+        0x43425844, 0x20DAAA2B, 0x0D32B307, 0x886028DE, 0xD63037F3, 0x00000001, 0x00000164, 0x00000003,
+        0x0000002C, 0x00000060, 0x000000B4, 0x4E475349, 0x0000002C, 0x00000001, 0x00000008, 0x00000020,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000F0F, 0x49534F50, 0x4E4F4954, 0xABABAB00,
+        0x4E47534F, 0x0000004C, 0x00000002, 0x00000008, 0x00000038, 0x00000000, 0x00000001, 0x00000003,
+        0x00000000, 0x0000000F, 0x00000044, 0x00000000, 0x00000000, 0x00000003, 0x00000001, 0x0000000F,
+        0x505F5653, 0x5449534F, 0x004E4F49, 0x4F4C4F43, 0xABAB0052, 0x52444853, 0x000000A8, 0x00010040,
+        0x0000002A, 0x0300005F, 0x001010F2, 0x00000000, 0x04000067, 0x001020F2, 0x00000000, 0x00000001,
+        0x03000065, 0x001020F2, 0x00000001, 0x02000068, 0x00000001, 0x05000036, 0x001020F2, 0x00000000,
+        0x00101E46, 0x00000000, 0x07000031, 0x00100012, 0x00000000, 0x0010100A, 0x00000000, 0x00004001,
+        0x00000000, 0x0F000037, 0x001020F2, 0x00000001, 0x00100006, 0x00000000, 0x00004002, 0x00000000,
+        0x00000000, 0x3F800000, 0x3F800000, 0x00004002, 0x3F800000, 0x00000000, 0x00000000, 0x3F800000,
+        0x0100003E
+    };
+
+    static const DWORD ps_code[] =
+    {
+#if 0
+    struct vertex_out
+    {
+        float4 pos : SV_POSITION;
+        nointerpolation float4 color : COLOR0;
+    };
+
+    float4 main(vertex_out vo) : SV_TARGET
+    {
+        return vo.color;
+    }
+#endif
+        0x43425844, 0x33D9B6B6, 0xB32F761F, 0xA3EBDFC9, 0xE2C9CDBD, 0x00000001, 0x000000F4, 0x00000003,
+        0x0000002C, 0x00000080, 0x000000B4, 0x4E475349, 0x0000004C, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000F, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000F0F, 0x505F5653, 0x5449534F, 0x004E4F49, 0x4F4C4F43, 0xABAB0052,
+        0x4E47534F, 0x0000002C, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003,
+        0x00000000, 0x0000000F, 0x545F5653, 0x45475241, 0xABAB0054, 0x52444853, 0x00000038, 0x00000040,
+        0x0000000E, 0x03000862, 0x001010F2, 0x00000001, 0x03000065, 0x001020F2, 0x00000000, 0x05000036,
+        0x001020F2, 0x00000000, 0x00101E46, 0x00000001, 0x0100003E
+    };
+
+    static const D3D11_INPUT_ELEMENT_DESC layout_desc[] =
+    {
+        { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+    };
+
+    static const struct vec2 quad[] =
+    {
+        { -1.0f, -1.0f },
+        { -1.0f,  1.0f },
+        {  1.0f, -1.0f },
+        {  1.0f,  1.0f },
+    };
+
+    if (!init_test_context(&test_context, NULL))
+        return;
+
+    device = test_context.device;
+    context = test_context.immediate_context;
+
+    hr = ID3D11Device_CreateInputLayout(device, layout_desc, 1, vs_code, sizeof(vs_code), &layout);
+    ok(SUCCEEDED(hr), "Failed to create input layout, hr %#x.\n", hr);
+    vb = create_buffer(device, D3D11_BIND_VERTEX_BUFFER, sizeof(quad), quad);
+    hr = ID3D11Device_CreateVertexShader(device, vs_code, sizeof(vs_code), NULL, &vs);
+    ok(SUCCEEDED(hr), "Failed to create vertex shader, hr %#x.\n", hr);
+    hr = ID3D11Device_CreatePixelShader(device, ps_code, sizeof(ps_code), NULL, &ps);
+    ok(SUCCEEDED(hr), "Failed to create pixel shader, hr %#x.\n", hr);
+
+    ID3D11DeviceContext_IASetInputLayout(context, layout);
+    ID3D11DeviceContext_IASetPrimitiveTopology(context, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+    stride = sizeof(quad[0]);
+    offset = 0;
+    ID3D11DeviceContext_IASetVertexBuffers(context, 0, 1, &vb, &stride, &offset);
+    ID3D11DeviceContext_VSSetShader(context, vs, NULL, 0);
+    ID3D11DeviceContext_PSSetShader(context, ps, NULL, 0);
+
+    ID3D11DeviceContext_Draw(context, 4, 0);
+    check_texture_color(test_context.backbuffer, 0xffff0000, 1);
+
+    ID3D11Buffer_Release(vb);
+    ID3D11InputLayout_Release(layout);
+    ID3D11PixelShader_Release(ps);
+    ID3D11VertexShader_Release(vs);
+    release_test_context(&test_context);
+}
+
+static void test_tbuffer(void)
+{
+    D3D11_SHADER_RESOURCE_VIEW_DESC view_desc;
+    HRESULT hr;
+    ID3D11Buffer *vb, *tb;
+    ID3D11Device *device;
+    ID3D11DeviceContext *context;
+    ID3D11InputLayout *layout;
+    ID3D11PixelShader *ps;
+    ID3D11ShaderResourceView *tb_view;
+    ID3D11VertexShader *vs;
+    UINT stride, offset;
+    struct d3d11_test_context test_context;
+
+    static const DWORD vs_code[] =
+    {
+#if 0
+    float4 main(float4 pos : POSITION) : SV_POSITION
+    {
+        return pos;
+    }
+#endif
+        0x43425844, 0x77f030d7, 0x18f13b6b, 0x47fff01f, 0x97ead6d3, 0x00000001, 0x000001b4, 0x00000005,
+        0x00000034, 0x0000008c, 0x000000c0, 0x000000f4, 0x00000138, 0x46454452, 0x00000050, 0x00000000,
+        0x00000000, 0x00000000, 0x0000001c, 0xfffe0400, 0x00000100, 0x0000001c, 0x7263694d, 0x666f736f,
+        0x52282074, 0x4c482029, 0x53204c53, 0x65646168, 0x6f432072, 0x6c69706d, 0x36207265, 0x392e332e,
+        0x2e303036, 0x38333631, 0xabab0034, 0x4e475349, 0x0000002c, 0x00000001, 0x00000008, 0x00000020,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000f0f, 0x49534f50, 0x4e4f4954, 0xababab00,
+        0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000001, 0x00000003,
+        0x00000000, 0x0000000f, 0x505f5653, 0x5449534f, 0x004e4f49, 0x52444853, 0x0000003c, 0x00010040,
+        0x0000000f, 0x0300005f, 0x001010f2, 0x00000000, 0x04000067, 0x001020f2, 0x00000000, 0x00000001,
+        0x05000036, 0x001020f2, 0x00000000, 0x00101e46, 0x00000000, 0x0100003e, 0x54415453, 0x00000074,
+        0x00000002, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+    };
+
+    static const DWORD ps_code[] =
+    {
+#if 0
+    tbuffer buf : register(t0)
+    {
+        float4 color;
+    };
+
+    float4 main() : SV_TARGET
+    {
+        return color;
+    }
+#endif
+        0x43425844, 0x921b0266, 0x0d6e2f9c, 0x7e3b529c, 0xab5ab054, 0x00000001, 0x0000022c, 0x00000005,
+        0x00000034, 0x000000f8, 0x00000108, 0x0000013c, 0x000001b0, 0x46454452, 0x000000bc, 0x00000001,
+        0x00000040, 0x00000001, 0x0000001c, 0xffff0400, 0x00000100, 0x00000088, 0x0000003c, 0x00000001,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00667562, 0x0000003c,
+        0x00000001, 0x00000058, 0x00000010, 0x00000000, 0x00000001, 0x00000070, 0x00000000, 0x00000010,
+        0x00000002, 0x00000078, 0x00000000, 0x6f6c6f63, 0xabab0072, 0x00030001, 0x00040001, 0x00000000,
+        0x00000000, 0x7263694d, 0x666f736f, 0x52282074, 0x4c482029, 0x53204c53, 0x65646168, 0x6f432072,
+        0x6c69706d, 0x36207265, 0x392e332e, 0x2e303036, 0x38333631, 0xabab0034, 0x4e475349, 0x00000008,
+        0x00000000, 0x00000008, 0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000,
+        0x00000000, 0x00000003, 0x00000000, 0x0000000f, 0x545f5653, 0x45475241, 0xabab0054, 0x52444853,
+        0x0000006c, 0x00000040, 0x0000001b, 0x04000858, 0x00107000, 0x00000000, 0x00006666, 0x03000065,
+        0x001020f2, 0x00000000, 0x02000068, 0x00000001, 0x0a00002d, 0x001000f2, 0x00000000, 0x00004002,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00107e46, 0x00000000, 0x05000036, 0x001020f2,
+        0x00000000, 0x00100e46, 0x00000000, 0x0100003e, 0x54415453, 0x00000074, 0x00000003, 0x00000001,
+        0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000,
+        0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+        0x00000000, 0x00000000, 0x00000000
+    };
+
+    static const D3D11_INPUT_ELEMENT_DESC layout_desc[] =
+    {
+        { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+    };
+
+    static const struct vec2 quad[] =
+    {
+        { -1.0f, -1.0f },
+        { -1.0f,  1.0f },
+        { 1.0f, -1.0f },
+        { 1.0f,  1.0f },
+    };
+
+    static const struct vec4 color[] =
+    {
+        { 1.0f, 1.0f, 0.0f, 1.0f },
+    };
+    static const float red[] = {1.0f, 0.0f, 0.0f, 1.0f};
+
+    if (!init_test_context(&test_context, NULL))
+        return;
+
+    device = test_context.device;
+    context = test_context.immediate_context;
+    ID3D11DeviceContext_ClearRenderTargetView(context, test_context.backbuffer_rtv, red);
+
+    hr = ID3D11Device_CreateInputLayout(device, layout_desc, 1, vs_code, sizeof(vs_code), &layout);
+    ok(SUCCEEDED(hr), "Failed to create input layout, hr %#x.\n", hr);
+    vb = create_buffer(device, D3D11_BIND_VERTEX_BUFFER, sizeof(quad), quad);
+    hr = ID3D11Device_CreateVertexShader(device, vs_code, sizeof(vs_code), NULL, &vs);
+    ok(SUCCEEDED(hr), "Failed to create vertex shader, hr %#x.\n", hr);
+    hr = ID3D11Device_CreatePixelShader(device, ps_code, sizeof(ps_code), NULL, &ps);
+    ok(SUCCEEDED(hr), "Failed to create pixel shader, hr %#x.\n", hr);
+
+    tb = create_buffer(device, D3D11_BIND_SHADER_RESOURCE, sizeof(color), color);
+    view_desc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
+    view_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
+    view_desc.Buffer.ElementOffset = 0;
+    view_desc.Buffer.ElementWidth = 1;
+    hr = ID3D11Device_CreateShaderResourceView(device, (ID3D11Resource*)tb, &view_desc, &tb_view);
+    ok(SUCCEEDED(hr), "Failed to create texture buffer view, hr %#x.\n", hr);
+
+    ID3D11DeviceContext_IASetInputLayout(context, layout);
+    ID3D11DeviceContext_IASetPrimitiveTopology(context, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+    stride = sizeof(quad[0]);
+    offset = 0;
+    ID3D11DeviceContext_IASetVertexBuffers(context, 0, 1, &vb, &stride, &offset);
+    ID3D11DeviceContext_VSSetShader(context, vs, NULL, 0);
+    ID3D11DeviceContext_PSSetShader(context, ps, NULL, 0);
+
+    ID3D11DeviceContext_PSSetShaderResources(context, 0, 1, &tb_view);
+
+    ID3D11DeviceContext_Draw(context, 4, 0);
+    check_texture_color(test_context.backbuffer, 0xff00ffff, 1);
+
+    ID3D11ShaderResourceView_Release(tb_view);
+    ID3D11Buffer_Release(tb);
+    ID3D11Buffer_Release(vb);
+    ID3D11InputLayout_Release(layout);
+    ID3D11PixelShader_Release(ps);
+    ID3D11VertexShader_Release(vs);
+    release_test_context(&test_context);
+}
+
+static void test_sm4_vertexid(void)
+{
+    struct d3d11_test_context test_context;
+    ID3D11PixelShader *ps;
+    ID3D11DeviceContext *context;
+    ID3D11Device *device;
+    DWORD expected_color;
+    ID3D11Buffer *ib;
+    HRESULT hr;
+    unsigned int stride, offset;
+
+    static const DWORD ps_code[] =
+    {
+#if 0
+struct VSOut
+{
+    float4 pos : SV_Position;
+    float4 color : color;
+};
+
+float4 main(VSOut input) : SV_TARGET
+{
+    return input.color;
+}
+#endif
+        0x43425844, 0x119e48d1, 0x468aecb3, 0x0a405be5, 0x4e203b82, 0x00000001, 0x000000f4, 0x00000003,
+        0x0000002c, 0x00000080, 0x000000b4, 0x4e475349, 0x0000004c, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000f0f, 0x505f5653, 0x7469736f, 0x006e6f69, 0x6f6c6f63, 0xabab0072,
+        0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003,
+        0x00000000, 0x0000000f, 0x545f5653, 0x45475241, 0xabab0054, 0x52444853, 0x00000038, 0x00000040,
+        0x0000000e, 0x03001062, 0x001010f2, 0x00000001, 0x03000065, 0x001020f2, 0x00000000, 0x05000036,
+        0x001020f2, 0x00000000, 0x00101e46, 0x00000001, 0x0100003e
+    };
+    static const D3D11_INPUT_ELEMENT_DESC layout_desc[] =
+    {
+        { "SV_Position", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+        { "SV_VertexID", 0, DXGI_FORMAT_R32_UINT, 1, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+    };
+    static const DWORD vs_code[] =
+    {
+#if 0
+struct VSIn
+{
+    float4 pos : SV_Position;
+    uint vertexid : SV_VertexID;
+};
+
+struct VSOut
+{
+    float4 pos : SV_Position;
+    float4 color : color;
+};
+
+VSOut main(VSIn input)
+{
+    VSOut output;
+    if (input.vertexid < 4)
+        output.color = float4(0.0, 1.0, 1.0, 1.0);
+    else
+        output.color = float4(1.0, 0.0, 0.0, 1.0);
+    output.pos = input.pos;
+    return output;
+}
+#endif
+        0x43425844, 0xcbc9ab23, 0x3f01a208, 0x1df619da, 0xe93cc736, 0x00000001, 0x00000198, 0x00000003,
+        0x0000002c, 0x00000084, 0x000000d8, 0x4e475349, 0x00000050, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000f0f, 0x00000044, 0x00000000, 0x00000006,
+        0x00000001, 0x00000001, 0x00000101, 0x505f5653, 0x7469736f, 0x006e6f69, 0x565f5653, 0x65747265,
+        0x00444978, 0x4e47534f, 0x0000004c, 0x00000002, 0x00000008, 0x00000038, 0x00000000, 0x00000001,
+        0x00000003, 0x00000000, 0x0000000f, 0x00000044, 0x00000000, 0x00000000, 0x00000003, 0x00000001,
+        0x0000000f, 0x505f5653, 0x7469736f, 0x006e6f69, 0x6f6c6f63, 0xabab0072, 0x52444853, 0x000000b8,
+        0x00010040, 0x0000002e, 0x0300005f, 0x001010f2, 0x00000000, 0x04000060, 0x00101012, 0x00000001,
+        0x00000006, 0x04000067, 0x001020f2, 0x00000000, 0x00000001, 0x03000065, 0x001020f2, 0x00000001,
+        0x02000068, 0x00000001, 0x05000036, 0x001020f2, 0x00000000, 0x00101e46, 0x00000000, 0x0700004f,
+        0x00100012, 0x00000000, 0x0010100a, 0x00000001, 0x00004001, 0x00000004, 0x0f000037, 0x001020f2,
+        0x00000001, 0x00100006, 0x00000000, 0x00004002, 0x00000000, 0x3f800000, 0x3f800000, 0x3f800000,
+        0x00004002, 0x3f800000, 0x00000000, 0x00000000, 0x3f800000, 0x0100003e
+    };
+    static const struct vec2 vertices[] =
+    {
+        { 0.0f, 0.0f },
+        { 0.0f, 0.0f },
+        { 0.0f, 0.0f },
+        { 0.0f, 0.0f },
+        { -1.0f, -1.0f },
+        { -1.0f,  1.0f },
+        { 1.0f, -1.0f },
+        { 1.0f,  1.0f },
+    };
+    static const unsigned int indices[] =
+    {
+        0, 0, 0, 0, 0, 1, 2, 3
+    };
+
+    if (!init_test_context(&test_context, NULL))
+        return;
+
+    device = test_context.device;
+    context = test_context.immediate_context;
+
+    hr = ID3D11Device_CreatePixelShader(device, ps_code, sizeof(ps_code), NULL, &ps);
+    ok(SUCCEEDED(hr), "Failed to create return pixel shader, hr %#x.\n", hr);
+
+    ID3D11DeviceContext_PSSetShader(context, ps, NULL, 0);
+    expected_color = 0xffffff00;
+
+    ib = create_buffer(device, D3D11_BIND_INDEX_BUFFER, sizeof(indices), indices);
+
+    hr = ID3D11Device_CreateInputLayout(device, layout_desc,
+        sizeof(layout_desc) / sizeof(*layout_desc),
+        vs_code, sizeof(vs_code), &test_context.input_layout);
+    ok(SUCCEEDED(hr), "Failed to create input layout, hr %#x.\n", hr);
+
+    test_context.vb = create_buffer(device, D3D11_BIND_VERTEX_BUFFER, sizeof(vertices), vertices);
+
+    hr = ID3D11Device_CreateVertexShader(device, vs_code, sizeof(vs_code), NULL, &test_context.vs);
+    ok(SUCCEEDED(hr), "Failed to create vertex shader, hr %#x.\n", hr);
+
+    ID3D11DeviceContext_IASetInputLayout(test_context.immediate_context, test_context.input_layout);
+    ID3D11DeviceContext_IASetPrimitiveTopology(test_context.immediate_context, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+    stride = sizeof(*vertices);
+    offset = 0;
+    ID3D11DeviceContext_IASetVertexBuffers(test_context.immediate_context, 0, 1, &test_context.vb, &stride, &offset);
+    ID3D11DeviceContext_IASetIndexBuffer(test_context.immediate_context, ib, DXGI_FORMAT_R32_UINT, 0);
+    ID3D11DeviceContext_VSSetShader(test_context.immediate_context, test_context.vs, NULL, 0);
+
+    ID3D11DeviceContext_Draw(test_context.immediate_context, 4, 4);
+    check_texture_color(test_context.backbuffer, expected_color, 0);
+
+    ID3D11DeviceContext_DrawIndexed(test_context.immediate_context, 4, 4, 4);
+    check_texture_color(test_context.backbuffer, expected_color, 0);
+
+    ID3D11DeviceContext_DrawInstanced(test_context.immediate_context, 4, 1, 4, 0);
+    check_texture_color(test_context.backbuffer, expected_color, 0);
+
+    ID3D11DeviceContext_DrawIndexedInstanced(test_context.immediate_context, 4, 1, 4, 4, 0);
+    check_texture_color(test_context.backbuffer, expected_color, 0);
+
+    ID3D11Buffer_Release(ib);
+    ID3D11PixelShader_Release(ps);
+
+    release_test_context(&test_context);
+}
+
 static void test_geometry_shader(void)
 {
     static const struct
@@ -21422,6 +21815,9 @@
     test_resinfo_instruction();
     test_sm5_bufinfo_instruction();
     test_render_target_device_mismatch();
+    test_nointerpolation();
+    test_tbuffer();
+    test_sm4_vertexid();
     test_buffer_srv();
     run_for_each_feature_level_in_range(D3D_FEATURE_LEVEL_10_0, D3D_FEATURE_LEVEL_11_0,
             test_unaligned_raw_buffer_access);
diff -ur a/dlls/kernel32/version.c b/dlls/kernel32/version.c
--- a/dlls/kernel32/version.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/kernel32/version.c	2017-07-17 13:28:50.854078463 +0200
@@ -41,6 +41,16 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(ver);
 
+typedef struct PACKAGE_ID
+{
+    UINT32 reserved;
+    UINT32 processorArchitecture;
+    UINT64 version;
+    PWSTR name;
+    PWSTR publisher;
+    PWSTR resourceId;
+    PWSTR publisherId;
+} PACKAGE_ID;
 
 /***********************************************************************
  *         GetVersion   (KERNEL32.@)
@@ -207,8 +217,18 @@
  */
 LONG WINAPI GetCurrentPackageId(UINT32 *len, BYTE *buffer)
 {
-    FIXME("(%p %p): stub\n", len, buffer);
-    return APPMODEL_ERROR_NO_PACKAGE;
+    FIXME("(%p %p): partial stub\n", len, buffer);
+
+    if (*len < sizeof(PACKAGE_ID))
+    {
+        *len = sizeof(PACKAGE_ID);
+        return ERROR_INSUFFICIENT_BUFFER;
+    }
+
+    *len = sizeof(PACKAGE_ID);
+    memset(buffer, 0, sizeof(PACKAGE_ID));
+
+    return ERROR_SUCCESS;
 }
 
 /***********************************************************************
diff -ur a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
--- a/dlls/ntdll/loader.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ntdll/loader.c	2017-07-17 13:28:50.960744260 +0200
@@ -1537,6 +1537,13 @@
     return status;
 }
 
+NTSTATUS WINAPI LdrRegisterDllNotification(ULONG flags, void *notification_fn, PVOID context, PVOID *cookie)
+{
+    FIXME("(%08x, %p, %p, %p),  stub\n", flags, notification_fn, context, cookie);
+
+    return STATUS_SUCCESS;
+}
+
 /******************************************************************
  *		LdrDisableThreadCalloutsForDll (NTDLL.@)
  *
diff -ur a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
--- a/dlls/ntdll/Makefile.in	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ntdll/Makefile.in	2017-07-17 13:28:50.957410953 +0200
@@ -3,7 +3,7 @@
 IMPORTLIB = ntdll
 IMPORTS   = winecrt0
 EXTRALIBS = $(IOKIT_LIBS) $(RT_LIBS) $(PTHREAD_LIBS)
-EXTRADLLFLAGS = -nodefaultlibs -Wl,--image-base,0x7bc00000
+EXTRADLLFLAGS = -nodefaultlibs -Wl,--image-base,0x7bc00000 -Wb,--image-base,0x7bc00000 -Wb,--fake-native,$(MODULE).so
 
 C_SRCS = \
 	actctx.c \
diff -ur a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
--- a/dlls/ntdll/ntdll_misc.h	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ntdll/ntdll_misc.h	2017-07-17 13:28:50.960744260 +0200
@@ -225,25 +225,27 @@
 /* thread private data, stored in NtCurrentTeb()->SpareBytes1 */
 struct ntdll_thread_data
 {
+#if defined(__i386__) || defined(__x86_64__)
+    DWORD_PTR          dr0;           /* 1bc/2e8 Debug registers */
+    DWORD_PTR          dr1;           /* 1c0/2f0 */
+    DWORD_PTR          dr2;           /* 1c4/2f8 */
+    DWORD_PTR          dr3;           /* 1c8/300 */
+    DWORD_PTR          dr6;           /* 1cc/308 */
+    DWORD_PTR          dr7;           /* 1d0/310 */
+#endif
 #ifdef __i386__
-    DWORD              dr0;           /* 1bc Debug registers */
-    DWORD              dr1;           /* 1c0 */
-    DWORD              dr2;           /* 1c4 */
-    DWORD              dr3;           /* 1c8 */
-    DWORD              dr6;           /* 1cc */
-    DWORD              dr7;           /* 1d0 */
     DWORD              fs;            /* 1d4 TEB selector */
     DWORD              gs;            /* 1d8 libc selector; update winebuild if you move this! */
     void              *vm86_ptr;      /* 1dc data for vm86 mode */
 #else
-    void              *exit_frame;    /*    /2e8 exit frame pointer */
+    void              *exit_frame;    /*    /318 exit frame pointer */
 #endif
-    struct debug_info *debug_info;    /* 1e0/2f0 info for debugstr functions */
-    int                request_fd;    /* 1e4/2f8 fd for sending server requests */
-    int                reply_fd;      /* 1e8/2fc fd for receiving server replies */
-    int                wait_fd[2];    /* 1ec/300 fd for sleeping server requests */
-    BOOL               wow64_redir;   /* 1f4/308 Wow64 filesystem redirection flag */
-    pthread_t          pthread_id;    /* 1f8/310 pthread thread id */
+    struct debug_info *debug_info;    /* 1e0/320 info for debugstr functions */
+    int                request_fd;    /* 1e4/328 fd for sending server requests */
+    int                reply_fd;      /* 1e8/32c fd for receiving server replies */
+    int                wait_fd[2];    /* 1ec/330 fd for sleeping server requests */
+    BOOL               wow64_redir;   /* 1f4/338 Wow64 filesystem redirection flag */
+    pthread_t          pthread_id;    /* 1f8/340 pthread thread id */
 #ifdef __i386__
     WINE_VM86_TEB_INFO vm86;          /* 1fc vm86 private data */
     void              *exit_frame;    /* 204 exit frame pointer */
diff -ur a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
--- a/dlls/ntdll/ntdll.spec	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ntdll/ntdll.spec	2017-07-17 13:28:50.960744260 +0200
@@ -84,6 +84,7 @@
 @ stdcall LdrProcessRelocationBlock(ptr long ptr long)
 @ stdcall LdrQueryImageFileExecutionOptions(ptr wstr long ptr long ptr)
 @ stdcall LdrQueryProcessModuleInformation(ptr long ptr)
+@ stdcall LdrRegisterDllNotification(long ptr ptr ptr)
 @ stdcall LdrResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long)
 @ stub LdrSetAppCompatDllRedirectionCallback
 @ stub LdrSetDllManifestProber
diff -ur a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
--- a/dlls/ntdll/signal_x86_64.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ntdll/signal_x86_64.c	2017-07-17 13:28:50.964077566 +0200
@@ -1649,7 +1649,9 @@
  */
 static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
 {
-    context->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS;
+    struct ntdll_thread_data * const regs = ntdll_get_thread_data();
+
+    context->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_DEBUG_REGISTERS;
     context->Rax    = RAX_sig(sigcontext);
     context->Rcx    = RCX_sig(sigcontext);
     context->Rdx    = RDX_sig(sigcontext);
@@ -1686,6 +1688,12 @@
 #else
     __asm__("movw %%ss,%0" : "=m" (context->SegSs));
 #endif
+    context->Dr0          = regs->dr0;
+    context->Dr1          = regs->dr1;
+    context->Dr2          = regs->dr2;
+    context->Dr3          = regs->dr3;
+    context->Dr6          = regs->dr6;
+    context->Dr7          = regs->dr7;
     if (FPU_sig(sigcontext))
     {
         context->ContextFlags |= CONTEXT_FLOATING_POINT;
@@ -1702,6 +1710,14 @@
  */
 static void restore_context( const CONTEXT *context, ucontext_t *sigcontext )
 {
+    struct ntdll_thread_data * const regs = ntdll_get_thread_data();
+
+    regs->dr0 = context->Dr0;
+    regs->dr1 = context->Dr1;
+    regs->dr2 = context->Dr2;
+    regs->dr3 = context->Dr3;
+    regs->dr6 = context->Dr6;
+    regs->dr7 = context->Dr7;
     RAX_sig(sigcontext) = context->Rax;
     RCX_sig(sigcontext) = context->Rcx;
     RDX_sig(sigcontext) = context->Rdx;
@@ -1861,6 +1877,16 @@
 void set_cpu_context( const CONTEXT *context )
 {
     DWORD flags = context->ContextFlags & ~CONTEXT_AMD64;
+
+    if (flags & CONTEXT_DEBUG_REGISTERS)
+    {
+        ntdll_get_thread_data()->dr0 = context->Dr0;
+        ntdll_get_thread_data()->dr1 = context->Dr1;
+        ntdll_get_thread_data()->dr2 = context->Dr2;
+        ntdll_get_thread_data()->dr3 = context->Dr3;
+        ntdll_get_thread_data()->dr6 = context->Dr6;
+        ntdll_get_thread_data()->dr7 = context->Dr7;
+    }
     if (flags & CONTEXT_FULL)
     {
         if (!(flags & CONTEXT_CONTROL))
@@ -2563,7 +2589,7 @@
         }
         break;
     }
-    status = raise_exception( rec, context, TRUE );
+    status = NtRaiseException( rec, context, TRUE );
     if (status) raise_status( status, rec );
 done:
     set_cpu_context( context );
@@ -2571,13 +2597,43 @@
 
 
 /**********************************************************************
+ *		raise_trap_exception
+ */
+static void raise_trap_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
+{
+    NTSTATUS status;
+
+    if (rec->ExceptionCode == EXCEPTION_SINGLE_STEP)
+    {
+        /* when single stepping can't tell whether this is a hw bp or a
+         * single step interrupt. try to avoid as much overhead as possible
+         * and only do a server call if there is any hw bp enabled. */
+
+        if( !(context->EFlags & 0x100) || (ntdll_get_thread_data()->dr7 & 0xff) )
+        {
+            /* (possible) hardware breakpoint, fetch the debug registers */
+            DWORD saved_flags = context->ContextFlags;
+            context->ContextFlags = CONTEXT_DEBUG_REGISTERS;
+            NtGetContextThread(GetCurrentThread(), context);
+            context->ContextFlags |= saved_flags;  /* restore flags */
+        }
+
+        context->EFlags &= ~0x100;  /* clear single-step flag */
+    }
+
+    status = NtRaiseException( rec, context, TRUE );
+    raise_status( status, rec );
+}
+
+
+/**********************************************************************
  *		raise_generic_exception
  *
  * Generic raise function for exceptions that don't need special treatment.
  */
 static void raise_generic_exception( EXCEPTION_RECORD *rec, CONTEXT *context )
 {
-    NTSTATUS status = raise_exception( rec, context, TRUE );
+    NTSTATUS status = NtRaiseException( rec, context, TRUE );
     if (status) raise_status( status, rec );
     set_cpu_context( context );
 }
@@ -2592,6 +2648,9 @@
 {
     switch(interrupt)
     {
+    case 0x2c:
+        rec->ExceptionCode = STATUS_ASSERTION_FAILURE;
+        return TRUE;
     case 0x2d:
         context->Rip += 3;
         rec->ExceptionCode = EXCEPTION_BREAKPOINT;
@@ -2655,7 +2714,6 @@
             WORD err = ERROR_sig(ucontext);
             if ((err & 7) == 2 && handle_interrupt( err >> 3, rec, win_context )) break;
             rec->ExceptionCode = err ? EXCEPTION_ACCESS_VIOLATION : EXCEPTION_PRIV_INSTRUCTION;
-            rec->ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
         }
         break;
     case TRAP_x86_PAGEFLT:  /* Page fault */
@@ -2688,7 +2746,8 @@
  */
 static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
-    EXCEPTION_RECORD *rec = setup_exception( sigcontext, raise_generic_exception );
+    ucontext_t *ucontext = sigcontext;
+    EXCEPTION_RECORD *rec = setup_exception( sigcontext, raise_trap_exception );
 
     switch (siginfo->si_code)
     {
@@ -2697,6 +2756,16 @@
         rec->ExceptionCode = EXCEPTION_SINGLE_STEP;
         break;
     case TRAP_BRKPT:   /* Breakpoint exception */
+    case SI_KERNEL:    /* Software breakpoint */
+        /* Check if this is actuallly icebp instruction */
+        if (((unsigned char *)rec->ExceptionAddress)[-1] == 0xF1)
+        {
+            rec->ExceptionCode = EXCEPTION_SINGLE_STEP;
+            break;
+        }
+        /* Validate assumption that SI_KERNEL == TRAP_x86_BPTFLT */
+        if (siginfo->si_code == SI_KERNEL && TRAP_sig(ucontext) != TRAP_x86_BPTFLT)
+            FIXME( "si_code == SI_KERNEL, but TRAP_sig(context) == %lld\n", TRAP_sig(ucontext) );
         rec->ExceptionAddress = (char *)rec->ExceptionAddress - 1;  /* back up over the int3 instruction */
         /* fall through */
     default:
diff -ur a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
--- a/dlls/ntdll/tests/exception.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ntdll/tests/exception.c	2017-07-17 13:28:50.964077566 +0200
@@ -111,6 +111,49 @@
     SETJMP_FLOAT128  Xmm15;
 } _JUMP_BUFFER;
 
+typedef enum _UNWIND_OP_CODES
+{
+    UWOP_PUSH_NONVOL = 0,
+    UWOP_ALLOC_LARGE,
+    UWOP_ALLOC_SMALL,
+    UWOP_SET_FPREG,
+    UWOP_SAVE_NONVOL,
+    UWOP_SAVE_NONVOL_FAR,
+    UWOP_SAVE_XMM128,
+    UWOP_SAVE_XMM128_FAR,
+    UWOP_PUSH_MACHFRAME
+} UNWIND_CODE_OPS;
+
+typedef union _UNWIND_CODE
+{
+    struct
+    {
+        BYTE CodeOffset;
+        BYTE UnwindOp : 4;
+        BYTE OpInfo   : 4;
+    } u;
+    USHORT FrameOffset;
+} UNWIND_CODE, *PUNWIND_CODE;
+
+typedef struct _UNWIND_INFO
+{
+    BYTE Version       : 3;
+    BYTE Flags         : 5;
+    BYTE SizeOfProlog;
+    BYTE CountOfCodes;
+    BYTE FrameRegister : 4;
+    BYTE FrameOffset   : 4;
+    UNWIND_CODE UnwindCode[1]; /* actually CountOfCodes (aligned) */
+/*
+ *  union
+ *  {
+ *      OPTIONAL ULONG ExceptionHandler;
+ *      OPTIONAL ULONG FunctionEntry;
+ *  };
+ *  OPTIONAL ULONG ExceptionData[];
+ */
+} UNWIND_INFO, *PUNWIND_INFO;
+
 static BOOLEAN   (CDECL *pRtlAddFunctionTable)(RUNTIME_FUNCTION*, DWORD, DWORD64);
 static BOOLEAN   (CDECL *pRtlDeleteFunctionTable)(RUNTIME_FUNCTION*);
 static BOOLEAN   (CDECL *pRtlInstallFunctionTableCallback)(DWORD64, DWORD64, DWORD, PGET_RUNTIME_FUNCTION_CALLBACK, PVOID, PCWSTR);
@@ -119,6 +162,7 @@
 static VOID      (WINAPI *pRtlCaptureContext)(CONTEXT*);
 static VOID      (CDECL *pRtlRestoreContext)(CONTEXT*, EXCEPTION_RECORD*);
 static VOID      (CDECL *pRtlUnwindEx)(VOID*, VOID*, EXCEPTION_RECORD*, VOID*, CONTEXT*, UNWIND_HISTORY_TABLE*);
+static PIMAGE_NT_HEADERS (WINAPI *pRtlImageNtHeader)(PVOID);
 static int       (CDECL *p_setjmp)(_JUMP_BUFFER*);
 #endif
 
@@ -1998,9 +2042,648 @@
     ok(dispatch.ScopeIndex == 1, "dispatch.ScopeIndex = %d\n", dispatch.ScopeIndex);
 }
 
+/* This is heavily based on the i386 exception tests. */
+static const struct exception
+{
+    BYTE     code[18];      /* asm code */
+    BYTE     offset;        /* offset of faulting instruction */
+    BYTE     length;        /* length of faulting instruction */
+    NTSTATUS status;        /* expected status code */
+    BOOL     todo;
+    DWORD    nb_params;     /* expected number of parameters */
+    ULONG64  params[4];     /* expected parameters */
+    NTSTATUS alt_status;    /* alternative status code */
+    DWORD    alt_nb_params; /* alternative number of parameters */
+    ULONG64  alt_params[4]; /* alternative parameters */
+} exceptions[] =
+{
+/* 0 */
+    /* test some privileged instructions */
+    { { 0xfb, 0xc3 },  /* 0: sti; ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x6c, 0xc3 },  /* 1: insb (%dx); ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x6d, 0xc3 },  /* 2: insl (%dx); ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x6e, 0xc3 },  /* 3: outsb (%dx); ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x6f, 0xc3 },  /* 4: outsl (%dx); ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+/* 5 */
+    { { 0xe4, 0x11, 0xc3 },  /* 5: inb $0x11,%al; ret */
+      0, 2, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0xe5, 0x11, 0xc3 },  /* 6: inl $0x11,%eax; ret */
+      0, 2, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0xe6, 0x11, 0xc3 },  /* 7: outb %al,$0x11; ret */
+      0, 2, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0xe7, 0x11, 0xc3 },  /* 8: outl %eax,$0x11; ret */
+      0, 2, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0xed, 0xc3 },  /* 9: inl (%dx),%eax; ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+/* 10 */
+    { { 0xee, 0xc3 },  /* 10: outb %al,(%dx); ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0xef, 0xc3 },  /* 11: outl %eax,(%dx); ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0xf4, 0xc3 },  /* 12: hlt; ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0xfa, 0xc3 },  /* 13: cli; ret */
+      0, 1, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+
+    /* test iret to invalid selector */
+    { { 0x6a, 0x00, 0x6a, 0x00, 0x6a, 0x00, 0xcf, 0x83, 0xc4, 0x18, 0xc3 },
+      /* 15: pushq $0; pushq $0; pushq $0; iret; addl $24,%esp; ret */
+      6, 1, STATUS_ACCESS_VIOLATION, TRUE, 2, { 0, 0xffffffffffffffff } },
+/* 15 */
+    /* test loading an invalid selector */
+    { { 0xb8, 0xef, 0xbe, 0x00, 0x00, 0x8e, 0xe8, 0xc3 },  /* 16: mov $beef,%ax; mov %ax,%gs; ret */
+      5, 2, STATUS_ACCESS_VIOLATION, TRUE, 2, { 0, 0xbee8 } }, /* 0xbee8 or 0xffffffff */
+
+    /* test overlong instruction (limit is 15 bytes) */
+    { { 0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0xfa,0xc3 },
+      0, 16, STATUS_ILLEGAL_INSTRUCTION, TRUE, 0, { 0 },
+      STATUS_ACCESS_VIOLATION, 2, { 0, 0xffffffffffffffff } },
+
+    /* test invalid interrupt */
+    { { 0xcd, 0xff, 0xc3 },   /* int $0xff; ret */
+      0, 2, STATUS_ACCESS_VIOLATION, TRUE, 2, { 0, 0xffffffffffffffff } },
+
+    /* test moves to/from Crx */
+    { { 0x0f, 0x20, 0xc0, 0xc3 },  /* movl %cr0,%eax; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x0f, 0x20, 0xe0, 0xc3 },  /* movl %cr4,%eax; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+/* 20 */
+    { { 0x0f, 0x22, 0xc0, 0xc3 },  /* movl %eax,%cr0; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x0f, 0x22, 0xe0, 0xc3 },  /* movl %eax,%cr4; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+
+    /* test moves to/from Drx */
+    { { 0x0f, 0x21, 0xc0, 0xc3 },  /* movl %dr0,%eax; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x0f, 0x21, 0xc8, 0xc3 },  /* movl %dr1,%eax; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x0f, 0x21, 0xf8, 0xc3 },  /* movl %dr7,%eax; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+/* 25 */
+    { { 0x0f, 0x23, 0xc0, 0xc3 },  /* movl %eax,%dr0; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x0f, 0x23, 0xc8, 0xc3 },  /* movl %eax,%dr1; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+    { { 0x0f, 0x23, 0xf8, 0xc3 },  /* movl %eax,%dr7; ret */
+      0, 3, STATUS_PRIVILEGED_INSTRUCTION, FALSE, 0 },
+
+    /* test memory reads */
+    { { 0xa1, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl 0xfffffffffffffffc,%eax; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 0, 0xfffffffffffffffc } },
+    { { 0xa1, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl 0xfffffffffffffffd,%eax; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 0, 0xfffffffffffffffd } },
+/* 30 */
+    { { 0xa1, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl 0xfffffffffffffffe,%eax; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 0, 0xfffffffffffffffe } },
+    { { 0xa1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl 0xffffffffffffffff,%eax; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 0, 0xffffffffffffffff } },
+
+    /* test memory writes */
+    { { 0xa3, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl %eax,0xfffffffffffffffc; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 1, 0xfffffffffffffffc } },
+    { { 0xa3, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl %eax,0xfffffffffffffffd; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 1, 0xfffffffffffffffd } },
+    { { 0xa3, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl %eax,0xfffffffffffffffe; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 1, 0xfffffffffffffffe } },
+/* 35 */
+    { { 0xa3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3 },  /* movl %eax,0xffffffffffffffff; ret */
+      0, 9, STATUS_ACCESS_VIOLATION, FALSE, 2, { 1, 0xffffffffffffffff } },
+
+    { { 0xf1, 0x90, 0xc3 },  /* icebp; nop; ret */
+      1, 1, STATUS_SINGLE_STEP, FALSE, 0 },
+
+    { { 0xcd, 0x2c, 0xc3 },
+      0, 2, STATUS_ASSERTION_FAILURE, FALSE, 0 },
+};
+
+static int got_exception;
+
+static DWORD run_exception_test(void *handler, const void* context,
+                               const void *code, unsigned int code_size,
+                               DWORD access)
+{
+    unsigned char buf[8 + 6 + 8 + 8];
+    RUNTIME_FUNCTION runtime_func;
+    UNWIND_INFO *unwind = (UNWIND_INFO *)buf;
+    DWORD (*func)(void) = code_mem;
+    DWORD oldaccess, oldaccess2, result;
+
+    runtime_func.BeginAddress = 0;
+    runtime_func.EndAddress = code_size;
+    runtime_func.UnwindData = 0x1000;
+
+    unwind->Version = 1;
+    unwind->Flags = UNW_FLAG_EHANDLER;
+    unwind->SizeOfProlog = 0;
+    unwind->CountOfCodes = 0;
+    unwind->FrameRegister = 0;
+    unwind->FrameOffset = 0;
+    *(ULONG *)&buf[4] = 0x1010;
+    *(const void **)&buf[8] = context;
+
+    buf[16] = 0xff;
+    buf[17] = 0x25;
+    *(ULONG *)&buf[18] = 2;
+    /* Must be 8-byte aligned to handled alignment check exceptions. */
+    *(void **)&buf[24] = handler;
+
+    memcpy((unsigned char *)code_mem + 0x1000, buf, sizeof(buf));
+    memcpy(code_mem, code, code_size);
+    if(access)
+        VirtualProtect(code_mem, code_size, access, &oldaccess);
+
+    pRtlAddFunctionTable(&runtime_func, 1, (ULONG_PTR)code_mem);
+    result = func();
+    pRtlDeleteFunctionTable(&runtime_func);
+
+    if(access)
+        VirtualProtect(code_mem, code_size, oldaccess, &oldaccess2);
+
+    return result;
+}
+
+static DWORD WINAPI handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                      CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    const struct exception *except = *(const struct exception **)(dispatcher->HandlerData);
+    unsigned int i, parameter_count, entry = except - exceptions;
+
+    got_exception++;
+    trace( "exception %u: %x flags:%x addr:%p\n",
+           entry, rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress );
+
+    if (except->todo)
+    {
+        if (rec->ExceptionCode != except->status)
+        {
+            todo_wine ok( rec->ExceptionCode == except->status ||
+                (except->alt_status != 0 && rec->ExceptionCode == except->alt_status),
+                "%u: Wrong exception code %x/%x\n", entry, rec->ExceptionCode, except->status );
+            goto skip_params;
+        }
+        else if (rec->NumberParameters != except->nb_params)
+        {
+            todo_wine ok( rec->NumberParameters == except->nb_params,
+                "%u: Unexpected parameter count %u/%u\n", entry, rec->NumberParameters, except->nb_params );
+            goto skip_params;
+        }
+    }
+
+    ok( rec->ExceptionCode == except->status ||
+        (except->alt_status != 0 && rec->ExceptionCode == except->alt_status),
+        "%u: Wrong exception code %x/%x\n", entry, rec->ExceptionCode, except->status );
+    ok( context->Rip == (DWORD_PTR)code_mem + except->offset,
+        "%u: Unexpected eip %#lx/%#lx\n", entry,
+        context->Rip, (DWORD_PTR)code_mem + except->offset );
+    ok( rec->ExceptionAddress == (char*)context->Rip ||
+        (rec->ExceptionCode == STATUS_BREAKPOINT && rec->ExceptionAddress == (char*)context->Rip + 1),
+        "%u: Unexpected exception address %p/%p\n", entry,
+        rec->ExceptionAddress, (char*)context->Rip );
+
+    if (except->status == STATUS_BREAKPOINT && is_wow64)
+        parameter_count = 1;
+    else if (except->alt_status == 0 || rec->ExceptionCode != except->alt_status)
+        parameter_count = except->nb_params;
+    else
+        parameter_count = except->alt_nb_params;
+
+    ok( rec->NumberParameters == parameter_count,
+        "%u: Unexpected parameter count %u/%u\n", entry, rec->NumberParameters, parameter_count );
+
+    /* Most CPUs (except Intel Core apparently) report a segment limit violation */
+    /* instead of page faults for accesses beyond 0xffffffffffffffff */
+    if (except->nb_params == 2 && except->params[1] >= 0xfffffffffffffffd)
+    {
+        if (rec->ExceptionInformation[0] == 0 && rec->ExceptionInformation[1] == 0xffffffffffffffff)
+            goto skip_params;
+    }
+
+    /* Seems that both 0xbee8 and 0xfffffffffffffffff can be returned in windows */
+    if (except->nb_params == 2 && rec->NumberParameters == 2
+        && except->params[1] == 0xbee8 && rec->ExceptionInformation[1] == 0xffffffffffffffff
+        && except->params[0] == rec->ExceptionInformation[0])
+    {
+        goto skip_params;
+    }
+
+    if (except->alt_status == 0 || rec->ExceptionCode != except->alt_status)
+    {
+        for (i = 0; i < rec->NumberParameters; i++)
+            ok( rec->ExceptionInformation[i] == except->params[i],
+                "%u: Wrong parameter %d: %lx/%lx\n",
+                entry, i, rec->ExceptionInformation[i], except->params[i] );
+    }
+    else
+    {
+        for (i = 0; i < rec->NumberParameters; i++)
+            ok( rec->ExceptionInformation[i] == except->alt_params[i],
+                "%u: Wrong parameter %d: %lx/%lx\n",
+                entry, i, rec->ExceptionInformation[i], except->alt_params[i] );
+    }
+
+skip_params:
+    /* don't handle exception if it's not the address we expected */
+    if (context->Rip != (DWORD_PTR)code_mem + except->offset) return ExceptionContinueSearch;
+
+    context->Rip += except->length;
+    return ExceptionContinueExecution;
+}
+
+static void test_prot_fault(void)
+{
+    unsigned int i;
+
+    for (i = 0; i < sizeof(exceptions)/sizeof(exceptions[0]); i++)
+    {
+        got_exception = 0;
+        run_exception_test(handler, &exceptions[i], &exceptions[i].code,
+                           sizeof(exceptions[i].code), 0);
+        ok( got_exception == (exceptions[i].status != 0),
+            "%u: bad exception count %d\n", i, got_exception );
+    }
+}
+
+static DWORD WINAPI unwind_rdi_rsi_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                      CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    if (rec->ExceptionCode != STATUS_BREAKPOINT)
+        return ExceptionContinueSearch;
+
+    RtlUnwind( (PVOID)context->Rsp, (PVOID)(context->Rip + 1), rec, NULL );
+    return ExceptionContinueSearch;
+}
+
+static const BYTE unwind_rdi_test_code[] = {
+        0x57,                                           /* push %rdi */
+        0x48, 0xc7, 0xc7, 0x55, 0x55, 0x55, 0x55,       /* mov $0x55555555, %rdi */
+        0xcc,                                           /* int3 */
+        0x48, 0x89, 0xf8,                               /* mov %rdi, %rax */
+        0x5f,                                           /* pop %rdi */
+        0xc3,                                           /* ret */
+};
+
+static const BYTE unwind_rsi_test_code[] = {
+        0x56,                                           /* push %rsi */
+        0x48, 0xc7, 0xc6, 0x33, 0x33, 0x33, 0x33,       /* mov $0x33333333, %rsi */
+        0xcc,                                           /* int3 */
+        0x48, 0x89, 0xf0,                               /* mov %rsi, %rax */
+        0x5e,                                           /* pop %rsi */
+        0xc3,                                           /* ret */
+};
+
+static void test_unwind_rdi_rsi(void)
+{
+    DWORD result;
+
+    result = run_exception_test(unwind_rdi_rsi_handler, NULL, unwind_rdi_test_code,
+            sizeof(unwind_rdi_test_code), 0);
+    ok( result == 0x55555555, "expected %x, got %x\n", 0x55555555, result );
+
+    result = run_exception_test(unwind_rdi_rsi_handler, NULL, unwind_rsi_test_code,
+            sizeof(unwind_rsi_test_code), 0);
+    ok( result == 0x33333333, "expected %x, got %x\n", 0x33333333, result );
+}
+
+struct dbgreg_test {
+    DWORD64 dr0, dr1, dr2, dr3, dr6, dr7;
+};
+
+/* test handling of debug registers */
+static DWORD WINAPI dreg_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                  CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    const struct dbgreg_test *test = *(const struct dbgreg_test **)(dispatcher->HandlerData);
+
+    context->Rip += 2; /* Skips the popq (%rax) */
+    context->Dr0 = test->dr0;
+    context->Dr1 = test->dr1;
+    context->Dr2 = test->dr2;
+    context->Dr3 = test->dr3;
+    context->Dr6 = test->dr6;
+    context->Dr7 = test->dr7;
+    return ExceptionContinueExecution;
+}
+
+#define CHECK_DEBUG_REG(n, m) \
+    ok((ctx.Dr##n & m) == test->dr##n, "(%d) failed to set debug register " #n " to %lx, got %lx\n", \
+       test_num, test->dr##n, ctx.Dr##n)
+
+static void check_debug_registers(int test_num, const struct dbgreg_test *test)
+{
+    CONTEXT ctx;
+    NTSTATUS status;
+
+    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
+    status = pNtGetContextThread(GetCurrentThread(), &ctx);
+    ok(status == STATUS_SUCCESS, "NtGetContextThread failed with %x\n", status);
+
+    CHECK_DEBUG_REG(0, ~0);
+    CHECK_DEBUG_REG(1, ~0);
+    CHECK_DEBUG_REG(2, ~0);
+    CHECK_DEBUG_REG(3, ~0);
+    CHECK_DEBUG_REG(6, 0x0f);
+    CHECK_DEBUG_REG(7, ~0xdc00);
+}
+
+static const BYTE segfault_code[5] = {
+        0x31, 0xc0, /* xor    %eax,%eax */
+        0x8f, 0x00, /* popq   (%rax) - cause exception */
+        0xc3        /* ret */
+};
+
+/* test the single step exception behaviour */
+static DWORD WINAPI single_step_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                         CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    got_exception++;
+    ok (!(context->EFlags & 0x100), "eflags has single stepping bit set\n");
+
+    if( got_exception < 3)
+        context->EFlags |= 0x100;  /* single step until popf instruction */
+    else {
+        /* show that the last single step exception on the popf instruction
+         * (which removed the TF bit), still is a EXCEPTION_SINGLE_STEP exception */
+        ok( rec->ExceptionCode == EXCEPTION_SINGLE_STEP,
+            "exception is not EXCEPTION_SINGLE_STEP: %x\n", rec->ExceptionCode);
+    }
+
+    return ExceptionContinueExecution;
+}
+
+static const BYTE single_stepcode[] = {
+    0x9c,                /* pushf */
+    0x58,                /* pop   %rax */
+    0x0d,0,1,0,0,        /* or    $0x100,%eax */
+    0x50,                /* push   %rax */
+    0x9d,                /* popf    */
+    0x35,0,1,0,0,        /* xor    $0x100,%eax */
+    0x50,                /* push   %rax */
+    0x9d,                /* popf    */
+    0x90,               /* nop     */
+    0xc3
+};
+
+/* Test the alignment check (AC) flag handling. */
+static const BYTE align_check_code[] = {
+    0x55,                          /* push   %rbp */
+    0x89,0xe5,                     /* mov    %rsp,%rbp */
+    0x9c,                          /* pushf   */
+    0x58,                          /* pop    %rax */
+    0x0d,0,0,4,0,               /* or     $0x40000,%eax */
+    0x50,                          /* push   %rax */
+    0x9d,                          /* popf    */
+    0x89,0xe0,                  /* mov %rsp, %rax */
+    0x8b,0x40,0x1,              /* mov 0x1(%rax), %eax - cause exception */
+    0x9c,                          /* pushf   */
+    0x58,                          /* pop    %rax */
+    0x25,0xff,0xff,0xfb,0xff,   /* and    $~0x40000,%eax */
+    0x50,                          /* push   %rax */
+    0x9d,                          /* popf    */
+    0x5d,                          /* pop    %rbp */
+    0xc3,                          /* ret     */
+};
+
+static DWORD WINAPI align_check_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                         CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    ok ( context->EFlags & 0x40000, "eflags has AC bit cleared\n" );
+    got_exception++;
+    context->EFlags &= ~0x40000;
+    return ExceptionContinueExecution;
+}
+
+/* Test the direction flag handling. */
+static const BYTE direction_flag_code[] = {
+    0x55,                          /* push   %ebp */
+    0x89,0xe5,                     /* mov    %esp,%ebp */
+    0xfd,                          /* std */
+    0xfa,                          /* cli - cause exception */
+    0x5d,                          /* pop    %ebp */
+    0xc3,                          /* ret     */
+};
+
+static DWORD WINAPI direction_flag_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                            CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+#ifdef __GNUC__
+    DWORD64 flags;
+    __asm__("pushf; pop %0; cld" : "=r" (flags) );
+    /* older windows versions don't clear DF properly so don't test */
+    if (flags & 0x400) trace( "eflags has DF bit set\n" );
+#endif
+    ok( context->EFlags & 0x400, "context eflags has DF bit cleared\n" );
+    got_exception++;
+    context->Rip++;  /* skip cli */
+    context->EFlags &= ~0x400;  /* make sure it is cleared on return */
+    return ExceptionContinueExecution;
+}
+
+/* test single stepping over hardware breakpoint */
+static DWORD WINAPI bpx_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                 CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    got_exception++;
+    ok( rec->ExceptionCode == EXCEPTION_SINGLE_STEP,
+        "wrong exception code: %x\n", rec->ExceptionCode);
+
+    if(got_exception == 1) {
+        /* hw bp exception on first nop */
+        ok( context->Rip == (DWORD64)code_mem, "rip is wrong:  %lx instead of %lx\n",
+                                             context->Rip, (DWORD64)code_mem);
+        ok( (context->Dr6 & 0xf) == 1, "B0 flag is not set in Dr6\n");
+        ok( !(context->Dr6 & 0x4000), "BS flag is set in Dr6\n");
+        context->Dr0 = context->Dr0 + 1;  /* set hw bp again on next instruction */
+        context->EFlags |= 0x100;       /* enable single stepping */
+    } else if(  got_exception == 2) {
+        /* single step exception on second nop */
+        ok( context->Rip == (DWORD64)code_mem + 1, "rip is wrong: %lx instead of %lx\n",
+                                                 context->Rip, (DWORD64)code_mem + 1);
+        ok( (context->Dr6 & 0x4000), "BS flag is not set in Dr6\n");
+       /* depending on the win version the B0 bit is already set here as well
+        ok( (context->Dr6 & 0xf) == 0, "B0...3 flags in Dr6 shouldn't be set\n"); */
+        context->EFlags |= 0x100;
+    } else if( got_exception == 3) {
+        /* hw bp exception on second nop */
+        ok( context->Rip == (DWORD64)code_mem + 1, "rip is wrong: %lx instead of %lx\n",
+                                                 context->Rip, (DWORD64)code_mem + 1);
+        ok( (context->Dr6 & 0xf) == 1, "B0 flag is not set in Dr6\n");
+        ok( !(context->Dr6 & 0x4000), "BS flag is set in Dr6\n");
+        context->Dr0 = 0;       /* clear breakpoint */
+        context->EFlags |= 0x100;
+    } else {
+        /* single step exception on ret */
+        ok( context->Rip == (DWORD64)code_mem + 2, "rip is wrong: %lx instead of %lx\n",
+                                                 context->Rip, (DWORD64)code_mem + 2);
+        ok( (context->Dr6 & 0xf) == 0, "B0...3 flags in Dr6 shouldn't be set\n");
+        ok( (context->Dr6 & 0x4000), "BS flag is not set in Dr6\n");
+    }
+
+    context->Dr6 = 0;  /* clear status register */
+    return ExceptionContinueExecution;
+}
+
+static const BYTE dummy_code[] = { 0x90, 0x90, 0x90, 0xc3 };  /* nop, nop, nop, ret */
+
+/* test int3 handling */
+static DWORD WINAPI int3_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                  CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    ok( rec->ExceptionAddress == code_mem, "exception address not at: %p, but at %p\n",
+                                           code_mem,  rec->ExceptionAddress);
+    ok( context->Rip == (DWORD64)code_mem, "rip not at: %p, but at %#lx\n", code_mem, context->Rip);
+    if(context->Rip == (DWORD64)code_mem) context->Rip++; /* skip breakpoint */
+
+    return ExceptionContinueExecution;
+}
+
+static const BYTE int3_code[] = { 0xCC, 0xc3 };  /* int 3, ret */
+
+static void test_exceptions(void)
+{
+    CONTEXT ctx;
+    NTSTATUS res;
+    struct dbgreg_test dreg_test;
+
+    if (!pNtGetContextThread || !pNtSetContextThread)
+    {
+        skip( "NtGetContextThread/NtSetContextThread not found\n" );
+        return;
+    }
+
+    /* test handling of debug registers */
+    memset(&dreg_test, 0, sizeof(dreg_test));
+
+    dreg_test.dr0 = 0x42424240;
+    dreg_test.dr2 = 0x126bb070;
+    dreg_test.dr3 = 0x0badbad0;
+    dreg_test.dr7 = 0xffff0115;
+    run_exception_test(dreg_handler, &dreg_test, &segfault_code, sizeof(segfault_code), 0);
+    check_debug_registers(1, &dreg_test);
+
+    dreg_test.dr0 = 0x42424242;
+    dreg_test.dr2 = 0x100f0fe7;
+    dreg_test.dr3 = 0x0abebabe;
+    dreg_test.dr7 = 0x115;
+    run_exception_test(dreg_handler, &dreg_test, &segfault_code, sizeof(segfault_code), 0);
+    check_debug_registers(2, &dreg_test);
+
+    /* test single stepping behavior */
+    got_exception = 0;
+    run_exception_test(single_step_handler, NULL, &single_stepcode, sizeof(single_stepcode), 0);
+    ok(got_exception == 3, "expected 3 single step exceptions, got %d\n", got_exception);
+
+    /* test alignment exceptions */
+    got_exception = 0;
+    run_exception_test(align_check_handler, NULL, align_check_code, sizeof(align_check_code), 0);
+    ok(got_exception == 1, "got %d alignment faults, expected 1\n", got_exception);
+
+    /* test direction flag */
+    got_exception = 0;
+    run_exception_test(direction_flag_handler, NULL, direction_flag_code, sizeof(direction_flag_code), 0);
+    ok(got_exception == 1, "got %d exceptions, expected 1\n", got_exception);
+
+    /* test single stepping over hardware breakpoint */
+    memset(&ctx, 0, sizeof(ctx));
+    ctx.Dr0 = (DWORD64) code_mem;  /* set hw bp on first nop */
+    ctx.Dr7 = 3;
+    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
+    res = pNtSetContextThread( GetCurrentThread(), &ctx);
+    ok( res == STATUS_SUCCESS, "NtSetContextThread failed with %x\n", res);
+
+    got_exception = 0;
+    run_exception_test(bpx_handler, NULL, dummy_code, sizeof(dummy_code), 0);
+    ok( got_exception == 4,"expected 4 exceptions, got %d\n", got_exception);
+
+    /* test int3 handling */
+    run_exception_test(int3_handler, NULL, int3_code, sizeof(int3_code), 0);
+}
+
+static DWORD WINAPI read_fault_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                        CONTEXT *context, DISPATCHER_CONTEXT *dispatcher )
+{
+    got_exception++;
+    context->Rip += 2; /* skip faulting read */
+    trace( "fault reading %lx\n", rec->ExceptionInformation[1] );
+    return ExceptionContinueExecution;
+}
+
+static const BYTE read_dword_code[] = {
+    0x48, 0x8b, 0x0d, 0x03, 0x00, 0x00, 0x00, /* mov 3(%rip), %rcx */
+    0x8b, 0x01,                               /* mov (%rcx), %eax */
+    0xc3,                                     /* ret */
+};
+
+static void test_mem_holes(void)
+{
+    BYTE code[sizeof(read_dword_code) + sizeof(char *)];
+    char *mem;
+    void *ntdll = GetModuleHandleA( "ntdll.dll" );
+    PIMAGE_NT_HEADERS nt = RtlImageNtHeader( ntdll );
+    DWORD size = nt->OptionalHeader.SizeOfImage;
+
+    memcpy(code, read_dword_code, sizeof(read_dword_code));
+
+    got_exception = 0;
+    for (mem = ntdll; mem < (char*)ntdll + size; mem += 0x1000)
+    {
+        *(char **)&code[sizeof(read_dword_code)] = mem;
+        run_exception_test(read_fault_handler, NULL, code, sizeof(code), 0);
+    }
+    ok( got_exception == 0, "expected 0 exceptions, got %d\n", got_exception);
+}
+
 #endif  /* __x86_64__ */
 
 #if defined(__i386__) || defined(__x86_64__)
+static const struct
+{
+    ULONG_PTR dr0, dr1, dr2, dr3, dr6, dr7;
+}
+debug_register_tests[] =
+{
+    { 0x42424240, 0, 0x126bb070, 0x0badbad0, 0, 0xffff0115 },
+    { 0x42424242, 0, 0x100f0fe7, 0x0abebabe, 0, 0x115 },
+};
+
+#if defined(__x86_64__)
+static DWORD WINAPI debug_register_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                      CONTEXT *ctx, DISPATCHER_CONTEXT *dispatcher )
+{
+    int i = **(int **)(dispatcher->HandlerData);
+
+    if (rec->ExceptionCode != STATUS_BREAKPOINT)
+        return ExceptionContinueSearch;
+
+    ok(ctx->Dr0 == debug_register_tests[i].dr0, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr0, ctx->Dr0);
+    ok(ctx->Dr1 == debug_register_tests[i].dr1, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr1, ctx->Dr1);
+    ok(ctx->Dr2 == debug_register_tests[i].dr2, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr2, ctx->Dr2);
+    ok(ctx->Dr3 == debug_register_tests[i].dr3, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr3, ctx->Dr3);
+    ok((ctx->Dr6 &  0xf00f) == debug_register_tests[i].dr6, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr6, ctx->Dr6);
+    ok((ctx->Dr7 & ~0xdc00) == debug_register_tests[i].dr7, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr7, ctx->Dr7);
+
+    ctx->Rip += 1;
+    return ExceptionContinueExecution;
+}
+
+/* Fill stack area above red zone with 0xff, then trigger exception. */
+static const BYTE debug_register_test_code[] = {
+        0x57,                                           /* push %rdi */
+        0x48, 0xc7, 0xc1, 0x00, 0x10, 0x00, 0x00,       /* mov $0x1000, %rcx */
+        0x48, 0x8d, 0xbc, 0x24, 0x80, 0xef, 0xff, 0xff, /* lea -0x1080(%rsp), %rdi */
+        0x48, 0xc7, 0xc0, 0xff, 0x00, 0x00, 0x00,       /* mov $0xff, %rax */
+        0xf3, 0xaa,                                     /* rep stosb */
+        0xcc,                                           /* int3 */
+        0x5f,                                           /* pop %rdi */
+        0xc3,                                           /* ret */
+};
+#endif
 
 static DWORD WINAPI register_check_thread(void *arg)
 {
@@ -2024,30 +2707,21 @@
 
 static void test_debug_registers(void)
 {
-    static const struct
-    {
-        ULONG_PTR dr0, dr1, dr2, dr3, dr6, dr7;
-    }
-    tests[] =
-    {
-        { 0x42424240, 0, 0x126bb070, 0x0badbad0, 0, 0xffff0115 },
-        { 0x42424242, 0, 0x100f0fe7, 0x0abebabe, 0, 0x115 },
-    };
     NTSTATUS status;
     CONTEXT ctx;
     HANDLE thread;
     int i;
 
-    for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++)
+    for (i = 0; i < sizeof(debug_register_tests)/sizeof(debug_register_tests[0]); i++)
     {
         memset(&ctx, 0, sizeof(ctx));
         ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
-        ctx.Dr0 = tests[i].dr0;
-        ctx.Dr1 = tests[i].dr1;
-        ctx.Dr2 = tests[i].dr2;
-        ctx.Dr3 = tests[i].dr3;
-        ctx.Dr6 = tests[i].dr6;
-        ctx.Dr7 = tests[i].dr7;
+        ctx.Dr0 = debug_register_tests[i].dr0;
+        ctx.Dr1 = debug_register_tests[i].dr1;
+        ctx.Dr2 = debug_register_tests[i].dr2;
+        ctx.Dr3 = debug_register_tests[i].dr3;
+        ctx.Dr6 = debug_register_tests[i].dr6;
+        ctx.Dr7 = debug_register_tests[i].dr7;
 
         status = pNtSetContextThread(GetCurrentThread(), &ctx);
         ok(status == STATUS_SUCCESS, "NtGetContextThread failed with %08x\n", status);
@@ -2057,12 +2731,16 @@
 
         status = pNtGetContextThread(GetCurrentThread(), &ctx);
         ok(status == STATUS_SUCCESS, "NtGetContextThread failed with %08x\n", status);
-        ok(ctx.Dr0 == tests[i].dr0, "test %d: expected %lx, got %lx\n", i, tests[i].dr0, (DWORD_PTR)ctx.Dr0);
-        ok(ctx.Dr1 == tests[i].dr1, "test %d: expected %lx, got %lx\n", i, tests[i].dr1, (DWORD_PTR)ctx.Dr1);
-        ok(ctx.Dr2 == tests[i].dr2, "test %d: expected %lx, got %lx\n", i, tests[i].dr2, (DWORD_PTR)ctx.Dr2);
-        ok(ctx.Dr3 == tests[i].dr3, "test %d: expected %lx, got %lx\n", i, tests[i].dr3, (DWORD_PTR)ctx.Dr3);
-        ok((ctx.Dr6 &  0xf00f) == tests[i].dr6, "test %d: expected %lx, got %lx\n", i, tests[i].dr6, (DWORD_PTR)ctx.Dr6);
-        ok((ctx.Dr7 & ~0xdc00) == tests[i].dr7, "test %d: expected %lx, got %lx\n", i, tests[i].dr7, (DWORD_PTR)ctx.Dr7);
+        ok(ctx.Dr0 == debug_register_tests[i].dr0, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr0, (DWORD_PTR)ctx.Dr0);
+        ok(ctx.Dr1 == debug_register_tests[i].dr1, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr1, (DWORD_PTR)ctx.Dr1);
+        ok(ctx.Dr2 == debug_register_tests[i].dr2, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr2, (DWORD_PTR)ctx.Dr2);
+        ok(ctx.Dr3 == debug_register_tests[i].dr3, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr3, (DWORD_PTR)ctx.Dr3);
+        ok((ctx.Dr6 &  0xf00f) == debug_register_tests[i].dr6, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr6, (DWORD_PTR)ctx.Dr6);
+        ok((ctx.Dr7 & ~0xdc00) == debug_register_tests[i].dr7, "test %d: expected %lx, got %lx\n", i, debug_register_tests[i].dr7, (DWORD_PTR)ctx.Dr7);
+
+#if defined(__x86_64__)
+        run_exception_test(debug_register_handler, &i, debug_register_test_code, sizeof(debug_register_test_code), 0);
+#endif
     }
 
     memset(&ctx, 0, sizeof(ctx));
@@ -2630,9 +3308,10 @@
                                                                  "RtlRestoreContext" );
     pRtlUnwindEx                       = (void *)GetProcAddress( hntdll,
                                                                  "RtlUnwindEx" );
+    pRtlImageNtHeader                  = (void *)GetProcAddress( hntdll,
+                                                                 "RtlImageNtHeader" );
     p_setjmp                           = (void *)GetProcAddress( hmsvcrt,
                                                                  "_setjmp" );
-
     test_debug_registers();
     test_outputdebugstring(1);
     test_ripevent(1);
@@ -2643,6 +3322,10 @@
     test_virtual_unwind();
     test___C_specific_handler();
     test_restore_context();
+    test_prot_fault();
+    test_unwind_rdi_rsi();
+    test_exceptions();
+    test_mem_holes();
 
     if (pRtlAddFunctionTable && pRtlDeleteFunctionTable && pRtlInstallFunctionTableCallback && pRtlLookupFunctionEntry)
       test_dynamic_unwind();
diff -ur a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
--- a/dlls/ntdll/thread.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ntdll/thread.c	2017-07-17 13:28:50.970744179 +0200
@@ -961,10 +961,14 @@
     DWORD dummy, i;
     BOOL self;
 
-#ifdef __i386__
+#if defined(__i386__) || defined(__x86_64__)
     /* on i386 debug registers always require a server call */
     self = (handle == GetCurrentThread());
+#ifdef __i386__
     if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386)))
+#elif defined(__x86_64__)
+    if (self && (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64)))
+#endif
     {
         self = (ntdll_get_thread_data()->dr0 == context->Dr0 &&
                 ntdll_get_thread_data()->dr1 == context->Dr1 &&
@@ -1120,9 +1124,13 @@
             copy_context( context, &ctx, ctx.ContextFlags & needed_flags );
             context->ContextFlags |= ctx.ContextFlags & needed_flags;
         }
-#ifdef __i386__
+#if defined(__i386__) || defined(__x86_64__)
         /* update the cached version of the debug registers */
+#ifdef __i386__
         if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
+#elif defined(__x86_64__)
+        if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64))
+#endif
         {
             ntdll_get_thread_data()->dr0 = context->Dr0;
             ntdll_get_thread_data()->dr1 = context->Dr1;
diff -ur a/dlls/user32/user32.spec b/dlls/user32/user32.spec
--- a/dlls/user32/user32.spec	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/user32/user32.spec	2017-07-17 13:28:51.087409894 +0200
@@ -385,6 +385,7 @@
 @ stdcall GetWindow(long long)
 @ stdcall GetWindowContextHelpId(long)
 @ stdcall GetWindowDC(long)
+@ stdcall GetWindowDisplayAffinity(long ptr)
 @ stdcall GetWindowInfo(long ptr)
 @ stdcall GetWindowLongA(long long)
 @ stdcall -arch=win64 GetWindowLongPtrA(long long)
@@ -688,6 +689,7 @@
 @ stdcall SetUserObjectSecurity(long ptr ptr)
 @ stdcall SetWinEventHook(long long long ptr long long long)
 @ stdcall SetWindowContextHelpId(long long)
+@ stdcall SetWindowDisplayAffinity(long long)
 @ stub SetWindowFullScreenState
 @ stdcall SetWindowLongA(long long long)
 @ stdcall -arch=win64 SetWindowLongPtrA(long long long)
diff -ur a/dlls/user32/win.c b/dlls/user32/win.c
--- a/dlls/user32/win.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/user32/win.c	2017-07-17 13:28:51.087409894 +0200
@@ -3537,7 +3537,7 @@
         if (!wndPtr || wndPtr == WND_OTHER_PROCESS || wndPtr == WND_DESKTOP) return FALSE;
         hwnd = wndPtr->obj.handle;  /* make it a full handle */
 
-        if (pfinfo->dwFlags) wparam = !(wndPtr->flags & WIN_NCACTIVATED);
+        if (pfinfo->dwFlags) wparam = (wndPtr->flags & WIN_NCACTIVATED) != 0;
         else wparam = (hwnd == GetForegroundWindow());
 
         WIN_ReleasePtr( wndPtr );
@@ -3986,3 +3986,17 @@
     SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
     return FALSE;
 }
+
+BOOL WINAPI GetWindowDisplayAffinity(HWND hwnd, DWORD *affinity)
+{
+    FIXME("(%p, %p) stub\n", hwnd, affinity);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+BOOL WINAPI SetWindowDisplayAffinity(HWND hwnd, DWORD affinity)
+{
+    FIXME("(%p, %08x) stub\n", hwnd, affinity);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
diff -ur a/dlls/wined3d/context.c b/dlls/wined3d/context.c
--- a/dlls/wined3d/context.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/context.c	2017-07-17 13:28:51.120742955 +0200
@@ -157,6 +157,12 @@
                 resource->target, resource->object, resource->level);
         checkGLcall("glFramebufferTexture1D()");
     }
+    else if (resource->target == GL_TEXTURE_3D)
+    {
+        GL_EXTCALL(glFramebufferTexture(fbo_target, attachment,
+                resource->object, resource->level));
+        checkGLcall("glFramebufferTexture3D()");
+    }
     else
     {
         gl_info->fbo_ops.glFramebufferTexture2D(fbo_target, attachment,
@@ -2312,6 +2318,10 @@
             *base = MAX_FRAGMENT_SAMPLERS;
             *count = MAX_VERTEX_SAMPLERS;
             break;
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            *base = MAX_FRAGMENT_SAMPLERS + MAX_VERTEX_SAMPLERS;
+            *count = MAX_GEOMETRY_SAMPLERS;
+            break;
         default:
             ERR("Unhandled shader type %#x.\n", shader_version->type);
             *base = 0;
@@ -3316,11 +3326,88 @@
     }
 }
 
+static BOOL context_unit_free_for_gs(const struct wined3d_context *context,
+        const struct wined3d_state *state, DWORD unit)
+{
+    const struct wined3d_shader_resource_info *ps_resource_info = NULL, *vs_resource_info = NULL;
+    DWORD current_mapping = context->rev_tex_unit_map[unit];
+
+    if (use_ps(state))
+        ps_resource_info = state->shader[WINED3D_SHADER_TYPE_PIXEL]->reg_maps.resource_info;
+    if (use_vs(state))
+        vs_resource_info = state->shader[WINED3D_SHADER_TYPE_VERTEX]->reg_maps.resource_info;
+
+    /* Not currently used */
+    if (current_mapping == WINED3D_UNMAPPED_STAGE)
+        return TRUE;
+
+    if (current_mapping < MAX_FRAGMENT_SAMPLERS)
+    {
+        /* Used by a fragment sampler */
+        if (!ps_resource_info)
+        {
+            /* No pixel shader, check fixed function */
+            return current_mapping >= MAX_TEXTURES || !(context->fixed_function_usage_map & (1u << current_mapping));
+        }
+
+        /* Pixel shader, check the shader's sampler map */
+        return !ps_resource_info[current_mapping].type;
+    }
+
+    current_mapping -= MAX_FRAGMENT_SAMPLERS;
+    if (current_mapping < MAX_VERTEX_SAMPLERS)
+    {
+        /* Used by a vertex sampler, check the shader's sampler map */
+        return !vs_resource_info || !vs_resource_info[current_mapping].type;
+    }
+
+    return TRUE;
+}
+
+static void context_map_gsamplers(struct wined3d_context *context, const struct wined3d_state *state)
+{
+    const struct wined3d_shader_resource_info *gs_resource_info =
+            state->shader[WINED3D_SHADER_TYPE_GEOMETRY]->reg_maps.resource_info;
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    int start = min(MAX_FRAGMENT_SAMPLERS + MAX_VERTEX_SAMPLERS, gl_info->limits.combined_samplers) - 1;
+    int i;
+
+    if (gl_info->limits.combined_samplers >= MAX_COMBINED_SAMPLERS)
+        return;
+
+    for (i = 0; i < MAX_GEOMETRY_SAMPLERS; ++i)
+    {
+        DWORD gsampler_idx = i + MAX_FRAGMENT_SAMPLERS + MAX_VERTEX_SAMPLERS;
+        if (gs_resource_info[i].type)
+        {
+            while (start >= 0)
+            {
+                if (context_unit_free_for_gs(context, state, start))
+                {
+                    if (context->tex_unit_map[gsampler_idx] != start)
+                    {
+                        context_map_stage(context, gsampler_idx, start);
+                        context_invalidate_state(context, STATE_SAMPLER(gsampler_idx));
+                    }
+
+                    --start;
+                    break;
+                }
+
+                --start;
+            }
+            if (context->tex_unit_map[gsampler_idx] == WINED3D_UNMAPPED_STAGE)
+                WARN("Couldn't find a free texture unit for vertex sampler %u.\n", i);
+        }
+    }
+}
+
 static void context_update_tex_unit_map(struct wined3d_context *context, const struct wined3d_state *state)
 {
     const struct wined3d_gl_info *gl_info = context->gl_info;
     BOOL vs = use_vs(state);
     BOOL ps = use_ps(state);
+    BOOL gs = use_gs(state);
 
     if (!ps)
         context_update_fixed_function_usage_map(context, state);
@@ -3340,6 +3427,9 @@
 
     if (vs)
         context_map_vsamplers(context, ps, state);
+
+    if (gs)
+        context_map_gsamplers(context, state);
 }
 
 /* Context activation is done by the caller. */
@@ -3600,6 +3690,15 @@
 {
     unsigned int i;
 
+    if (use_gs(state))
+    {
+        for (i = 0; i < MAX_GEOMETRY_SAMPLERS; ++i)
+        {
+            if (state->shader[WINED3D_SHADER_TYPE_GEOMETRY]->reg_maps.resource_info[i].type)
+                context_preload_texture(context, state, MAX_FRAGMENT_SAMPLERS + MAX_VERTEX_SAMPLERS + i);
+        }
+    }
+
     if (use_vs(state))
     {
         for (i = 0; i < MAX_VERTEX_SAMPLERS; ++i)
diff -ur a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
--- a/dlls/wined3d/cs.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/cs.c	2017-07-17 13:28:51.120742955 +0200
@@ -750,6 +750,9 @@
         device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
     }
 
+    state->base_vertex_index = op->indexed ? op->base_vertex_idx : op->start_idx;
+    device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+
     if (state->gl_primitive_type != op->primitive_type)
     {
         if (state->gl_primitive_type == GL_POINTS || op->primitive_type == GL_POINTS)
diff -ur a/dlls/wined3d/device.c b/dlls/wined3d/device.c
--- a/dlls/wined3d/device.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/device.c	2017-07-17 13:28:51.120742955 +0200
@@ -4321,6 +4321,71 @@
         return WINED3D_OK;
 
     resource = view->resource;
+    if (resource->type == WINED3D_RTYPE_TEXTURE_3D)
+    {
+        const struct wined3d_gl_info *gl_info;
+        struct wined3d_context *context;
+        struct wined3d_texture *texture = texture_from_resource(resource);
+        struct gl_texture *gl_texture = wined3d_texture_get_gl_texture(texture, FALSE);
+        unsigned int i;
+        GLuint fbo;
+        GLenum draw_buffer = GL_COLOR_ATTACHMENT0;
+
+        ERR("Clearing 3D target, flags=%x\n", flags);
+
+        context = context_acquire(device, NULL, 0);
+        gl_info = context->gl_info;
+
+        wined3d_texture_prepare_texture(texture, context, FALSE);
+
+        if (flags & WINED3DCLEAR_TARGET)
+        {
+            gl_info->gl_ops.gl.p_glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+            context_invalidate_state(context, STATE_RENDER(WINED3D_RS_COLORWRITEENABLE));
+            context_invalidate_state(context, STATE_RENDER(WINED3D_RS_COLORWRITEENABLE1));
+            context_invalidate_state(context, STATE_RENDER(WINED3D_RS_COLORWRITEENABLE2));
+            context_invalidate_state(context, STATE_RENDER(WINED3D_RS_COLORWRITEENABLE3));
+            gl_info->gl_ops.gl.p_glClearColor(color->r, color->g, color->b, color->a);
+            checkGLcall("glClearColor");
+        }
+
+        if (rect)
+            ERR("ignoring rect\n");
+
+        context_invalidate_state(context, STATE_RENDER(WINED3D_RS_SCISSORTESTENABLE));
+        gl_info->gl_ops.gl.p_glDisable(GL_SCISSOR_TEST);
+
+        gl_info->fbo_ops.glGenFramebuffers(1, &fbo);
+        checkGLcall("glGenFramebuffers()");
+
+        gl_info->fbo_ops.glBindFramebuffer(GL_FRAMEBUFFER, fbo);
+        checkGLcall("glBindFramebuffer()");
+
+        for (i = 0; i < view->layer_count; i++)
+        {
+            gl_info->fbo_ops.glFramebufferTexture3D(GL_FRAMEBUFFER, draw_buffer,
+                    GL_TEXTURE_3D, gl_texture->name, gl_texture->base_level, i);
+            checkGLcall("glFramebufferTexture3D()");
+
+            GL_EXTCALL(glDrawBuffers(1, &draw_buffer));
+            checkGLcall("glDrawBuffers()");
+
+            gl_info->gl_ops.gl.p_glClear(GL_COLOR_BUFFER_BIT);
+            checkGLcall("glClear");
+        }
+
+        gl_info->fbo_ops.glBindFramebuffer(GL_FRAMEBUFFER, 0);
+        checkGLcall("glBindFramebuffer()");
+        gl_info->fbo_ops.glDeleteFramebuffers(1, &fbo);
+        checkGLcall("glDeleteFramebuffer()");
+
+        if (wined3d_settings.strict_draw_ordering)
+            gl_info->gl_ops.gl.p_glFlush();
+
+        context_release(context);
+        return WINED3D_OK;
+    }
+
     if (resource->type != WINED3D_RTYPE_TEXTURE_2D)
     {
         FIXME("Not implemented for %s resources.\n", debug_d3dresourcetype(resource->type));
diff -ur a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
--- a/dlls/wined3d/directx.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/directx.c	2017-07-17 13:28:51.120742955 +0200
@@ -109,6 +109,7 @@
     {"GL_APPLE_ycbcr_422",                  APPLE_YCBCR_422               },
 
     /* ARB */
+    {"GL_ARB_base_instance",                ARB_BASE_INSTANCE             },
     {"GL_ARB_blend_func_extended",          ARB_BLEND_FUNC_EXTENDED       },
     {"GL_ARB_clear_buffer_object",          ARB_CLEAR_BUFFER_OBJECT       },
     {"GL_ARB_clear_texture",                ARB_CLEAR_TEXTURE             },
@@ -219,6 +220,7 @@
     {"GL_EXT_framebuffer_blit",             EXT_FRAMEBUFFER_BLIT          },
     {"GL_EXT_framebuffer_multisample",      EXT_FRAMEBUFFER_MULTISAMPLE   },
     {"GL_EXT_framebuffer_object",           EXT_FRAMEBUFFER_OBJECT        },
+    {"GL_EXT_geometry_shader4",             EXT_GEOMETRY_SHADER4          },
     {"GL_EXT_gpu_program_parameters",       EXT_GPU_PROGRAM_PARAMETERS    },
     {"GL_EXT_gpu_shader4",                  EXT_GPU_SHADER4               },
     {"GL_EXT_packed_depth_stencil",         EXT_PACKED_DEPTH_STENCIL      },
@@ -2698,6 +2700,9 @@
     /* GL_APPLE_flush_buffer_range */
     USE_GL_FUNC(glBufferParameteriAPPLE)
     USE_GL_FUNC(glFlushMappedBufferRangeAPPLE)
+    /* GL_ARB_base_instance */
+    USE_GL_FUNC(glDrawArraysInstancedBaseInstance)
+    USE_GL_FUNC(glDrawElementsInstancedBaseVertexBaseInstance)
     /* GL_ARB_blend_func_extended */
     USE_GL_FUNC(glBindFragDataLocationIndexed)
     USE_GL_FUNC(glGetFragDataIndex)
diff -ur a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
--- a/dlls/wined3d/drawprim.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/drawprim.c	2017-07-17 13:28:51.120742955 +0200
@@ -72,6 +72,23 @@
         return;
     }
 
+    if (gl_info->supported[ARB_BASE_INSTANCE] && start_instance)
+    {
+        if (!idx_size)
+        {
+            GL_EXTCALL(glDrawArraysInstancedBaseInstance(state->gl_primitive_type, start_idx, count,
+                    instance_count, start_instance));
+            checkGLcall("glDrawArraysInstancedBaseInstance");
+            return;
+        }
+
+        GL_EXTCALL(glDrawElementsInstancedBaseVertexBaseInstance(state->gl_primitive_type, count, idx_type,
+                    (const char *)idx_data + (idx_size * start_idx), instance_count, base_vertex_idx,
+                    start_instance));
+        checkGLcall("glDrawElementsInstancedBaseVertexBaseInstance");
+        return;
+    }
+
     if (start_instance)
         FIXME("Start instance (%u) not supported.\n", start_instance);
 
diff -ur a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
--- a/dlls/wined3d/glsl_shader.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/glsl_shader.c	2017-07-17 13:28:51.124076261 +0200
@@ -143,6 +143,7 @@
     GLint uniform_i_locations[WINED3D_MAX_CONSTS_I];
     GLint uniform_b_locations[WINED3D_MAX_CONSTS_B];
     GLint pos_fixup_location;
+    GLint base_vertex_location;
 
     GLint modelview_matrix_location[MAX_VERTEX_BLENDS];
     GLint projection_matrix_location;
@@ -1771,6 +1772,12 @@
         checkGLcall("glUniform4fv");
     }
 
+    if (update_mask & WINED3D_SHADER_CONST_BASE_VERTEX)
+    {
+        GL_EXTCALL(glUniform1i(prog->vs.base_vertex_location, state->base_vertex_index));
+        checkGLcall("glUniform1i");
+    }
+
     if (update_mask & WINED3D_SHADER_CONST_FFP_MODELVIEW)
     {
         struct wined3d_matrix mat;
@@ -2125,21 +2132,69 @@
 }
 
 static void shader_glsl_declare_shader_inputs(const struct wined3d_gl_info *gl_info,
-        struct wined3d_string_buffer *buffer, unsigned int element_count)
+        struct wined3d_string_buffer *buffer, unsigned int element_count,
+        const enum wined3d_shader_interpolation_mode *interpolation_mode)
 {
+    unsigned int i;
     if (shader_glsl_use_interface_blocks(gl_info))
-        shader_addline(buffer, "in shader_in_out { vec4 reg[%u]; } shader_in;\n", element_count);
+    {
+        shader_addline(buffer, "in shader_in_out {\n");
+        for (i = 0; i < element_count; i++)
+        {
+            shader_addline(buffer, " %svec4 reg%u;\n",
+                (interpolation_mode && interpolation_mode[i] == WINED3DSIM_CONSTANT) ? "flat " : "",
+                i);
+        }
+        shader_addline(buffer, "} shader_in;\n");
+    }
     else
-        declare_in_varying(gl_info, buffer, FALSE, "vec4 ps_link[%u];\n", element_count);
+    {
+        for (i = 0; i < element_count; i++)
+        {
+            declare_in_varying(gl_info, buffer, interpolation_mode && interpolation_mode[i] == WINED3DSIM_CONSTANT,
+                "vec4 ps_link%u;\n", i);
+        }
+    }
 }
 
 static void shader_glsl_declare_shader_outputs(const struct wined3d_gl_info *gl_info,
-        struct wined3d_string_buffer *buffer, unsigned int element_count)
+        struct wined3d_string_buffer *buffer, unsigned int element_count, BOOL rasterizer_setup,
+        const enum wined3d_shader_interpolation_mode *interpolation_mode)
 {
+    unsigned int i;
     if (shader_glsl_use_interface_blocks(gl_info))
-        shader_addline(buffer, "out shader_in_out { vec4 reg[%u]; } shader_out;\n", element_count);
+    {
+        shader_addline(buffer, "out shader_in_out {\n");
+        if (rasterizer_setup)
+        {
+            for (i = 0; i < element_count; i++)
+            {
+                shader_addline(buffer, " %svec4 reg%u;\n",
+                    (interpolation_mode && interpolation_mode[i] == WINED3DSIM_CONSTANT) ? "flat " : "",
+                    i);
+            }
+        }
+        else
+        {
+            shader_addline(buffer, " vec4 reg[%u];\n", element_count);
+        }
+        shader_addline(buffer, "} shader_out;\n");
+    }
     else
-        declare_out_varying(gl_info, buffer, FALSE, "vec4 ps_link[%u];\n", element_count);
+    {
+        if (rasterizer_setup)
+        {
+            for (i = 0; i < element_count; i++)
+            {
+                declare_out_varying(gl_info, buffer, interpolation_mode && interpolation_mode[i] == WINED3DSIM_CONSTANT,
+                    "vec4 ps_link%u;\n", i);
+            }
+        }
+        else
+        {
+            declare_out_varying(gl_info, buffer, FALSE, "vec4 ps_link[%u];\n", element_count);
+        }
+    }
 }
 
 static const char *get_fragment_output(const struct wined3d_gl_info *gl_info)
@@ -2230,7 +2285,8 @@
 
     if (e->sysval_semantic == WINED3D_SV_VERTEX_ID)
     {
-        shader_addline(buffer, "vec4 vs_in%u = vec4(intBitsToFloat(gl_VertexID), 0.0, 0.0, 0.0);\n",
+        shader_addline(buffer, "uniform int base_vertex;\n");
+        shader_addline(buffer, "vec4 vs_in%u = vec4(intBitsToFloat(gl_VertexID - base_vertex), 0.0, 0.0, 0.0);\n",
                 index);
         return;
     }
@@ -2431,6 +2487,8 @@
         switch (reg_maps->resource_info[entry->resource_idx].type)
         {
             case WINED3D_SHADER_RESOURCE_BUFFER:
+                if (shadow_sampler)
+                    FIXME("Unsupported Buffer shadow sampler.\n");
                 sampler_type = "samplerBuffer";
                 break;
 
@@ -2741,6 +2799,7 @@
     const struct wined3d_shader_version *version = &reg_maps->shader_version;
     const struct wined3d_gl_info *gl_info = ins->ctx->gl_info;
     const char *prefix = shader_glsl_get_prefix(version->type);
+    struct shader_glsl_ctx_priv *priv = ins->ctx->backend_data;
     struct glsl_src_param rel_param0, rel_param1;
     char imm_str[4][17];
 
@@ -2760,8 +2819,6 @@
         case WINED3DSPR_INCONTROLPOINT:
             if (version->type == WINED3D_SHADER_TYPE_VERTEX)
             {
-                struct shader_glsl_ctx_priv *priv = ins->ctx->backend_data;
-
                 if (reg->idx[0].rel_addr)
                     FIXME("VS3+ input registers relative addressing.\n");
                 if (priv->cur_vs_args->swizzle_map & (1u << reg->idx[0].offset))
@@ -2904,7 +2961,10 @@
                 WARN("Write to render target %u, only %d supported.\n",
                         reg->idx[0].offset, gl_info->limits.buffers);
 
-            sprintf(register_name, "%s[%u]", get_fragment_output(gl_info), reg->idx[0].offset);
+            if (version->type == WINED3D_SHADER_TYPE_PIXEL && priv->cur_ps_args->dual_source_blend)
+                sprintf(register_name, "dualFragData%u", reg->idx[0].offset);
+            else
+                sprintf(register_name, "%s[%u]", get_fragment_output(gl_info), reg->idx[0].offset);
             break;
 
         case WINED3DSPR_RASTOUT:
@@ -3492,7 +3552,10 @@
             ERR("Unexpected flags %#x for texelFetch.\n", flags & ~texel_fetch_flags);
 
         base = "texelFetch";
-        type_part = "";
+        if (resource_type == WINED3D_SHADER_RESOURCE_BUFFER)
+            type_part = "Buffer";
+        else
+            type_part = "";
     }
 
     sample_function->name = string_buffer_get(priv->string_buffers);
@@ -5854,11 +5917,21 @@
 
     shader_glsl_get_sample_function(ins->ctx, resource_idx, sampler_idx, flags, &sample_function);
     shader_glsl_add_src_param(ins, &ins->src[0], sample_function.coord_mask, &coord_param);
-    shader_glsl_add_src_param(ins, &ins->src[0], WINED3DSP_WRITEMASK_3, &lod_param);
-    sampler_bind_idx = shader_glsl_find_sampler(&reg_maps->sampler_map, resource_idx, sampler_idx);
-    shader_glsl_gen_sample_code(ins, sampler_bind_idx, &sample_function, ins->src[1].swizzle,
-            NULL, NULL, has_lod_param ? lod_param.param_str : NULL, &ins->texel_offset,
-            "%s", coord_param.param_str);
+    if (ins->ctx->reg_maps->resource_info[resource_idx].type == WINED3D_SHADER_RESOURCE_BUFFER)
+    {
+        /* texelFetchBuffer does not have a lod argument */
+        sampler_bind_idx = shader_glsl_find_sampler(&ins->ctx->reg_maps->sampler_map, resource_idx, sampler_idx);
+        shader_glsl_gen_sample_code(ins, sampler_bind_idx, &sample_function, ins->src[1].swizzle,
+                NULL, NULL, NULL, &ins->texel_offset, "%s", coord_param.param_str);
+    }
+    else
+    {
+        shader_glsl_add_src_param(ins, &ins->src[0], WINED3DSP_WRITEMASK_3, &lod_param);
+        sampler_bind_idx = shader_glsl_find_sampler(&reg_maps->sampler_map, resource_idx, sampler_idx);
+        shader_glsl_gen_sample_code(ins, sampler_bind_idx, &sample_function, ins->src[1].swizzle,
+                NULL, NULL, has_lod_param ? lod_param.param_str : NULL, &ins->texel_offset,
+                "%s", coord_param.param_str);
+    }
     shader_glsl_release_sample_function(ins->ctx, &sample_function);
 }
 
@@ -6550,7 +6623,7 @@
             {
                 if (input->sysval_semantic)
                     FIXME("Unhandled sysval semantic %#x.\n", input->sysval_semantic);
-                shader_addline(buffer, "ps_in[%u]%s = %s[%u]%s;\n",
+                shader_addline(buffer, "ps_in[%u]%s = %s%u%s;\n",
                         shader->u.ps.input_reg_map[input->register_idx], reg_mask,
                         shader_glsl_shader_input_name(gl_info),
                         shader->u.ps.input_reg_map[input->register_idx], reg_mask);
@@ -6678,7 +6751,7 @@
         else if (in_idx == in_count + 1)
             string_buffer_sprintf(destination, "gl_FrontSecondaryColor");
         else
-            string_buffer_sprintf(destination, "%s[%u]", out_array_name, in_idx);
+            string_buffer_sprintf(destination, "%s%u", out_array_name, in_idx);
 
         if (!set[in_idx])
             set[in_idx] = ~0u;
@@ -6730,7 +6803,7 @@
         else if (i == in_count + 1)
             string_buffer_sprintf(destination, "gl_FrontSecondaryColor");
         else
-            string_buffer_sprintf(destination, "%s[%u]", out_array_name, i);
+            string_buffer_sprintf(destination, "%s%u", out_array_name, i);
 
         if (size == 1)
             shader_addline(buffer, "%s.%s = 0.0;\n", destination->buffer, reg_mask);
@@ -6744,7 +6817,8 @@
 
 static void shader_glsl_setup_sm4_shader_output(struct shader_glsl_priv *priv,
         unsigned int input_count, const struct wined3d_shader_signature *output_signature,
-        const struct wined3d_shader_reg_maps *reg_maps_out, const char *output_variable_name)
+        const struct wined3d_shader_reg_maps *reg_maps_out, const char *output_variable_name,
+        BOOL rasterizer_setup)
 {
     struct wined3d_string_buffer *buffer = &priv->shader_buffer;
     char reg_mask[6];
@@ -6765,8 +6839,16 @@
 
         shader_glsl_write_mask_to_str(output->mask, reg_mask);
 
-        shader_addline(buffer, "%s.reg[%u]%s = outputs[%u]%s;\n",
-                output_variable_name, output->register_idx, reg_mask, output->register_idx, reg_mask);
+        if (rasterizer_setup)
+        {
+            shader_addline(buffer, "%s.reg%u%s = outputs[%u]%s;\n",
+                    output_variable_name, output->register_idx, reg_mask, output->register_idx, reg_mask);
+        }
+        else
+        {
+            shader_addline(buffer, "%s.reg[%u]%s = outputs[%u]%s;\n",
+                    output_variable_name, output->register_idx, reg_mask, output->register_idx, reg_mask);
+        }
     }
 }
 
@@ -6775,7 +6857,8 @@
         const struct wined3d_shader_signature *input_signature,
         const struct wined3d_shader_reg_maps *reg_maps_in, unsigned int input_count,
         const struct wined3d_shader_signature *output_signature,
-        const struct wined3d_shader_reg_maps *reg_maps_out, BOOL per_vertex_point_size)
+        const struct wined3d_shader_reg_maps *reg_maps_out, BOOL per_vertex_point_size,
+        const enum wined3d_shader_interpolation_mode *interpolation_mode)
 {
     struct wined3d_string_buffer *buffer = &priv->shader_buffer;
     const char *semantic_name;
@@ -6824,7 +6907,7 @@
         shader_glsl_setup_vs3_output(priv, gl_info, map, input_signature, reg_maps_in,
                 output_signature, reg_maps_out);
     else
-        shader_glsl_setup_sm4_shader_output(priv, input_count, output_signature, reg_maps_out, "shader_out");
+        shader_glsl_setup_sm4_shader_output(priv, input_count, output_signature, reg_maps_out, "shader_out", TRUE);
 }
 
 /* Context activation is done by the caller. */
@@ -6956,10 +7039,10 @@
     {
         unsigned int in_count = min(vec4_varyings(ps_major, gl_info), ps->limits->packed_input);
 
-        shader_glsl_declare_shader_outputs(gl_info, buffer, in_count);
+        shader_glsl_declare_shader_outputs(gl_info, buffer, in_count, TRUE, NULL);
         shader_addline(buffer, "void setup_vs_output(in vec4 outputs[%u])\n{\n", vs->limits->packed_output);
         shader_glsl_setup_sm3_rasterizer_input(priv, gl_info, ps->u.ps.input_reg_map, &ps->input_signature,
-                &ps->reg_maps, 0, &vs->output_signature, &vs->reg_maps, per_vertex_point_size);
+                &ps->reg_maps, 0, &vs->output_signature, &vs->reg_maps, per_vertex_point_size, NULL);
     }
 
     shader_addline(buffer, "}\n");
@@ -6973,7 +7056,8 @@
 
 static void shader_glsl_generate_sm4_output_setup(struct shader_glsl_priv *priv,
         const struct wined3d_shader *shader, unsigned int input_count,
-        const struct wined3d_gl_info *gl_info, BOOL rasterizer_setup)
+        const struct wined3d_gl_info *gl_info, BOOL rasterizer_setup,
+        const enum wined3d_shader_interpolation_mode *interpolation_mode)
 {
     const char *prefix = shader_glsl_get_prefix(shader->reg_maps.shader_version.type);
     struct wined3d_string_buffer *buffer = &priv->shader_buffer;
@@ -6982,17 +7066,17 @@
         input_count = min(vec4_varyings(4, gl_info), input_count);
 
     if (input_count)
-        shader_glsl_declare_shader_outputs(gl_info, buffer, input_count);
+        shader_glsl_declare_shader_outputs(gl_info, buffer, input_count, rasterizer_setup, interpolation_mode);
 
     shader_addline(buffer, "void setup_%s_output(in vec4 outputs[%u])\n{\n",
             prefix, shader->limits->packed_output);
 
     if (rasterizer_setup)
         shader_glsl_setup_sm3_rasterizer_input(priv, gl_info, NULL, NULL,
-                NULL, input_count, &shader->output_signature, &shader->reg_maps, FALSE);
+                NULL, input_count, &shader->output_signature, &shader->reg_maps, FALSE, interpolation_mode);
     else
         shader_glsl_setup_sm4_shader_output(priv, input_count, &shader->output_signature,
-                &shader->reg_maps, "shader_out");
+                &shader->reg_maps, "shader_out", FALSE);
 
     shader_addline(buffer, "}\n");
 }
@@ -7168,10 +7252,14 @@
         shader_addline(buffer, "#extension GL_ARB_texture_query_levels : enable\n");
     if (gl_info->supported[ARB_UNIFORM_BUFFER_OBJECT])
         shader_addline(buffer, "#extension GL_ARB_uniform_buffer_object : enable\n");
+    if (gl_info->supported[EXT_GEOMETRY_SHADER4])
+        shader_addline(buffer, "#extension GL_EXT_geometry_shader4 : enable\n");
     if (gl_info->supported[EXT_GPU_SHADER4])
         shader_addline(buffer, "#extension GL_EXT_gpu_shader4 : enable\n");
     if (gl_info->supported[EXT_TEXTURE_ARRAY])
         shader_addline(buffer, "#extension GL_EXT_texture_array : enable\n");
+    if (gl_info->supported[ARB_TEXTURE_CUBE_MAP_ARRAY])
+        shader_addline(buffer, "#extension GL_ARB_texture_cube_map_array : enable\n");
 }
 
 static void shader_glsl_generate_ps_epilogue(const struct wined3d_gl_info *gl_info,
@@ -7305,8 +7393,14 @@
         unsigned int in_count = min(vec4_varyings(version->major, gl_info), shader->limits->packed_input);
 
         if (args->vp_mode == vertexshader && reg_maps->input_registers)
-            shader_glsl_declare_shader_inputs(gl_info, buffer, in_count);
+            shader_glsl_declare_shader_inputs(gl_info, buffer, in_count, shader->u.ps.interpolation_mode);
         shader_addline(buffer, "vec4 %s_in[%u];\n", prefix, in_count);
+
+        if (args->dual_source_blend)
+        {
+            shader_addline(buffer, "varying out vec4 dualFragData0;\n");
+            shader_addline(buffer, "varying out vec4 dualFragData1;\n");
+        }
     }
 
     for (i = 0, map = reg_maps->bumpmat; map; map >>= 1, ++i)
@@ -7557,7 +7651,7 @@
 
     if (reg_maps->shader_version.major >= 4)
         shader_glsl_generate_sm4_output_setup(priv, shader, args->next_shader_input_count,
-                gl_info, args->next_shader_type == WINED3D_SHADER_TYPE_PIXEL);
+                gl_info, args->next_shader_type == WINED3D_SHADER_TYPE_PIXEL, args->interpolation_mode);
 
     shader_addline(buffer, "void main()\n{\n");
 
@@ -7662,7 +7756,7 @@
         shader_addline(buffer, "void setup_hs_output(in vec4 outputs[%u])\n{\n",
                 shader->limits->packed_output);
         shader_glsl_setup_sm4_shader_output(priv, shader->limits->packed_output, &shader->output_signature,
-                &shader->reg_maps, "shader_out[gl_InvocationID]");
+                &shader->reg_maps, "shader_out[gl_InvocationID]", FALSE);
         shader_addline(buffer, "}\n");
     }
 
@@ -7798,7 +7892,7 @@
         shader_addline(buffer, "uniform vec4 pos_fixup;\n");
 
     shader_glsl_generate_sm4_output_setup(priv, shader, args->output_count, gl_info,
-            args->next_shader_type == WINED3D_SHADER_TYPE_PIXEL);
+            args->next_shader_type == WINED3D_SHADER_TYPE_PIXEL, args->interpolation_mode);
     shader_glsl_generate_patch_constant_setup(buffer, &shader->patch_constant_signature, TRUE);
 
     shader_addline(buffer, "void main()\n{\n");
@@ -7847,7 +7941,7 @@
     if (!gl_info->supported[ARB_CLIP_CONTROL])
         shader_addline(buffer, "uniform vec4 pos_fixup;\n");
 
-    shader_glsl_generate_sm4_output_setup(priv, shader, args->output_count, gl_info, TRUE);
+    shader_glsl_generate_sm4_output_setup(priv, shader, args->output_count, gl_info, TRUE, args->interpolation_mode);
     shader_addline(buffer, "void main()\n{\n");
     if (FAILED(shader_generate_code(shader, buffer, reg_maps, &priv_ctx, NULL, NULL)))
         return 0;
@@ -8008,6 +8102,7 @@
 static inline BOOL vs_args_equal(const struct vs_compile_args *stored, const struct vs_compile_args *new,
         const DWORD use_map)
 {
+    unsigned int i;
     if((stored->swizzle_map & use_map) != new->swizzle_map) return FALSE;
     if((stored->clip_enabled) != new->clip_enabled) return FALSE;
     if (stored->point_size != new->point_size)
@@ -8020,7 +8115,14 @@
         return FALSE;
     if (stored->next_shader_input_count != new->next_shader_input_count)
         return FALSE;
-    return stored->fog_src == new->fog_src;
+    if (stored->fog_src != new->fog_src)
+        return FALSE;
+    for (i = 0; i < stored->next_shader_input_count; i++)
+    {
+        if (stored->interpolation_mode[i] != new->interpolation_mode[i])
+            return FALSE;
+    }
+    return TRUE;
 }
 
 static GLuint find_glsl_vshader(const struct wined3d_context *context, struct shader_glsl_priv *priv,
@@ -9430,6 +9532,7 @@
     }
 
     vs->pos_fixup_location = GL_EXTCALL(glGetUniformLocation(program_id, "pos_fixup"));
+    vs->base_vertex_location = GL_EXTCALL(glGetUniformLocation(program_id, "base_vertex"));
 
     for (i = 0; i < MAX_VERTEX_BLENDS; ++i)
     {
@@ -9929,6 +10032,14 @@
         GL_EXTCALL(glAttachShader(program_id, ps_id));
         checkGLcall("glAttachShader");
 
+        if (state_is_dual_source_blend(state))
+        {
+            GL_EXTCALL(glBindFragDataLocationIndexed(program_id, 0, 0, "dualFragData0"));
+            checkGLcall("glBindFragDataLocationIndexed");
+            GL_EXTCALL(glBindFragDataLocationIndexed(program_id, 0, 1, "dualFragData1"));
+            checkGLcall("glBindFragDataLocationIndexed");
+        }
+
         list_add_head(ps_list, &entry->ps.shader_entry);
     }
 
@@ -9980,6 +10091,8 @@
             entry->constant_update_mask |= WINED3D_SHADER_CONST_VS_B;
         if (entry->vs.pos_fixup_location != -1)
             entry->constant_update_mask |= WINED3D_SHADER_CONST_POS_FIXUP;
+        if (entry->vs.base_vertex_location != -1)
+            entry->constant_update_mask |= WINED3D_SHADER_CONST_BASE_VERTEX;
 
         shader_glsl_load_program_resources(context, priv, program_id, vshader);
     }
@@ -10702,7 +10815,7 @@
     /* WINED3DSIH_DCL_INPUT                        */ shader_glsl_nop,
     /* WINED3DSIH_DCL_INPUT_CONTROL_POINT_COUNT    */ shader_glsl_nop,
     /* WINED3DSIH_DCL_INPUT_PRIMITIVE              */ shader_glsl_nop,
-    /* WINED3DSIH_DCL_INPUT_PS                     */ NULL,
+    /* WINED3DSIH_DCL_INPUT_PS                     */ shader_glsl_nop,
     /* WINED3DSIH_DCL_INPUT_PS_SGV                 */ NULL,
     /* WINED3DSIH_DCL_INPUT_PS_SIV                 */ NULL,
     /* WINED3DSIH_DCL_INPUT_SGV                    */ shader_glsl_nop,
diff -ur a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
--- a/dlls/wined3d/shader.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/shader.c	2017-07-17 13:28:51.124076261 +0200
@@ -1077,6 +1077,16 @@
                     break;
             }
         }
+        else if (ins.handler_idx == WINED3DSIH_DCL_INPUT_PS)
+        {
+            unsigned int reg_idx = ins.declaration.dst.reg.idx[0].offset;
+            reg_maps->input_registers |= 1u << reg_idx;
+            if (shader_version.type == WINED3D_SHADER_TYPE_PIXEL)
+                shader->u.ps.interpolation_mode[reg_idx] = ins.flags;
+            else
+                FIXME("Invalid instruction %#x for shader type %#x.\n",
+                        ins.handler_idx, shader_version.type);
+        }
         else if (ins.handler_idx == WINED3DSIH_DCL_CONSTANT_BUFFER)
         {
             struct wined3d_shader_register *reg = &ins.declaration.src.reg;
@@ -3337,6 +3347,8 @@
 void find_vs_compile_args(const struct wined3d_state *state, const struct wined3d_shader *shader,
         WORD swizzle_map, struct vs_compile_args *args, const struct wined3d_d3d_info *d3d_info)
 {
+    unsigned int i;
+
     args->fog_src = state->render_states[WINED3D_RS_FOGTABLEMODE]
             == WINED3D_FOG_NONE ? VS_FOG_COORD : VS_FOG_Z;
     args->clip_enabled = state->render_states[WINED3D_RS_CLIPPING]
@@ -3360,6 +3372,12 @@
         args->flatshading = state->render_states[WINED3D_RS_SHADEMODE] == WINED3D_SHADE_FLAT;
     else
         args->flatshading = 0;
+
+    for (i = 0; i < args->next_shader_input_count; i++)
+    {
+        args->interpolation_mode[i] = state->shader[WINED3D_SHADER_TYPE_PIXEL]
+                ? state->shader[WINED3D_SHADER_TYPE_PIXEL]->u.ps.interpolation_mode[i] : 0;
+    }
 }
 
 static BOOL match_usage(BYTE usage1, BYTE usage_idx1, BYTE usage2, BYTE usage_idx2)
@@ -3629,6 +3647,7 @@
 void find_ds_compile_args(const struct wined3d_state *state, const struct wined3d_shader *shader,
         struct ds_compile_args *args, const struct wined3d_context *context)
 {
+    unsigned int i;
     const struct wined3d_shader *hull_shader = state->shader[WINED3D_SHADER_TYPE_HULL];
 
     args->tessellator_output_primitive = hull_shader->u.hs.tessellator_output_primitive;
@@ -3644,13 +3663,24 @@
     args->render_offscreen = context->render_offscreen;
 
     args->padding = 0;
+    for (i = 0; i < args->output_count; i++)
+    {
+        args->interpolation_mode[i] = state->shader[WINED3D_SHADER_TYPE_PIXEL]
+                ? state->shader[WINED3D_SHADER_TYPE_PIXEL]->u.ps.interpolation_mode[i] : 0;
+    }
 }
 
 void find_gs_compile_args(const struct wined3d_state *state, const struct wined3d_shader *shader,
         struct gs_compile_args *args)
 {
+    unsigned int i;
     args->output_count = state->shader[WINED3D_SHADER_TYPE_PIXEL]
             ? state->shader[WINED3D_SHADER_TYPE_PIXEL]->limits->packed_input : shader->limits->packed_output;
+    for (i = 0; i < args->output_count; i++)
+    {
+        args->interpolation_mode[i] = state->shader[WINED3D_SHADER_TYPE_PIXEL]
+                ? state->shader[WINED3D_SHADER_TYPE_PIXEL]->u.ps.interpolation_mode[i] : 0;
+    }
 }
 
 void find_ps_compile_args(const struct wined3d_state *state, const struct wined3d_shader *shader,
@@ -3885,6 +3915,8 @@
 
     args->render_offscreen = shader->reg_maps.vpos && gl_info->supported[ARB_FRAGMENT_COORD_CONVENTIONS]
             ? context->render_offscreen : 0;
+
+    args->dual_source_blend = state_is_dual_source_blend(state);
 }
 
 static HRESULT pixel_shader_init(struct wined3d_shader *shader, struct wined3d_device *device,
diff -ur a/dlls/wined3d/state.c b/dlls/wined3d/state.c
--- a/dlls/wined3d/state.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/state.c	2017-07-17 13:28:51.124076261 +0200
@@ -4642,11 +4642,6 @@
 
     if (target)
     {
-        if (vp.width > target->width)
-            vp.width = target->width;
-        if (vp.height > target->height)
-            vp.height = target->height;
-
         wined3d_rendertarget_view_get_drawable_size(target, context, &width, &height);
     }
     else if (depth_stencil)
@@ -4688,11 +4683,6 @@
 
     if (target)
     {
-        if (vp.width > target->width)
-            vp.width = target->width;
-        if (vp.height > target->height)
-            vp.height = target->height;
-
         wined3d_rendertarget_view_get_drawable_size(target, context, &width, &height);
     }
     else if (depth_stencil)
@@ -4986,6 +4976,11 @@
     WARN("Constant buffers (%s) no supported.\n", debug_d3dstate(state_id));
 }
 
+static void state_basevertex(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
+{
+    context->constant_update_mask |= WINED3D_SHADER_CONST_BASE_VERTEX;
+}
+
 static void state_shader_resource_binding(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id)
 {
@@ -5265,7 +5260,7 @@
     { STATE_SAMPLER(17), /* Vertex sampler 1 */           { STATE_SAMPLER(17),                                  sampler             }, WINED3D_GL_EXT_NONE             },
     { STATE_SAMPLER(18), /* Vertex sampler 2 */           { STATE_SAMPLER(18),                                  sampler             }, WINED3D_GL_EXT_NONE             },
     { STATE_SAMPLER(19), /* Vertex sampler 3 */           { STATE_SAMPLER(19),                                  sampler             }, WINED3D_GL_EXT_NONE             },
-    { STATE_BASEVERTEXINDEX,                              { STATE_BASEVERTEXINDEX,                              state_nop,          }, ARB_DRAW_ELEMENTS_BASE_VERTEX   },
+    { STATE_BASEVERTEXINDEX,                              { STATE_BASEVERTEXINDEX,                              state_basevertex,   }, ARB_DRAW_ELEMENTS_BASE_VERTEX   },
     { STATE_BASEVERTEXINDEX,                              { STATE_STREAMSRC,                                    NULL,               }, WINED3D_GL_EXT_NONE             },
     { STATE_FRAMEBUFFER,                                  { STATE_FRAMEBUFFER,                                  context_state_fb    }, WINED3D_GL_EXT_NONE             },
     { STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL),            { STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL),            context_state_drawbuf},WINED3D_GL_EXT_NONE             },
diff -ur a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
--- a/dlls/wined3d/texture.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/texture.c	2017-07-17 13:28:51.127409567 +0200
@@ -3170,8 +3170,9 @@
         const struct wined3d_parent_ops *parent_ops)
 {
     struct wined3d_device_parent *device_parent = device->device_parent;
+    struct wined3d_surface *surfaces;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-    unsigned int i;
+    unsigned int i, j, depth = desc->depth;
     HRESULT hr;
 
     if (layer_count != 1)
@@ -3253,26 +3254,52 @@
         texture->resource.map_binding = WINED3D_LOCATION_BUFFER;
     }
 
+    if (level_count > ~(SIZE_T)0 / depth
+            || !(surfaces = wined3d_calloc(level_count * depth, sizeof(*surfaces))))
+    {
+        wined3d_texture_cleanup_sync(texture);
+        return E_OUTOFMEMORY;
+    }
+
     /* Generate all the surfaces. */
     for (i = 0; i < texture->level_count; ++i)
     {
-        struct wined3d_texture_sub_resource *sub_resource;
-
-        sub_resource = &texture->sub_resources[i];
-        sub_resource->locations = WINED3D_LOCATION_DISCARDED;
-
-        if (FAILED(hr = device_parent->ops->volume_created(device_parent,
-                texture, i, &sub_resource->parent, &sub_resource->parent_ops)))
+        for (j = 0; j < depth; ++j)
         {
-            WARN("Failed to create volume parent, hr %#x.\n", hr);
-            sub_resource->parent = NULL;
-            wined3d_texture_cleanup_sync(texture);
-            return hr;
-        }
+            struct wined3d_texture_sub_resource *sub_resource;
+            unsigned int idx = j * texture->level_count + i;
+            struct wined3d_surface *surface;
+
+            surface = &surfaces[idx];
+            surface->container = texture;
+            surface->texture_target = texture->target;
+            surface->texture_level = i;
+            surface->texture_layer = j;
+            list_init(&surface->renderbuffers);
+            list_init(&surface->overlays);
+
+            sub_resource = &texture->sub_resources[idx];
+            sub_resource->locations = WINED3D_LOCATION_DISCARDED;
+            sub_resource->u.surface = surface;
+            if (!(texture->resource.usage & WINED3DUSAGE_DEPTHSTENCIL))
+            {
+                wined3d_texture_validate_location(texture, idx, WINED3D_LOCATION_SYSMEM);
+                wined3d_texture_invalidate_location(texture, idx, ~WINED3D_LOCATION_SYSMEM);
+            }
+
+            if (FAILED(hr = device_parent->ops->surface_created(device_parent,
+                    texture, idx, &sub_resource->parent, &sub_resource->parent_ops)))
+            {
+                WARN("Failed to create surface parent, hr %#x.\n", hr);
+                sub_resource->parent = NULL;
+                wined3d_texture_cleanup_sync(texture);
+                return hr;
+            }
 
-        TRACE("parent %p, parent_ops %p.\n", parent, parent_ops);
+            TRACE("parent %p, parent_ops %p.\n", sub_resource->parent, sub_resource->parent_ops);
 
-        TRACE("Created volume level %u.\n", i);
+            TRACE("Created 3D surface level %u, layer %u @ %p.\n", i, j, surface);
+        }
     }
 
     return WINED3D_OK;
@@ -3530,6 +3557,7 @@
         void *parent, const struct wined3d_parent_ops *parent_ops, struct wined3d_texture **texture)
 {
     struct wined3d_texture *object;
+    unsigned int depth_or_layer_count;
     HRESULT hr;
 
     TRACE("device %p, desc %p, layer_count %u, level_count %u, flags %#x, data %p, "
@@ -3575,8 +3603,13 @@
         }
     }
 
+    if (desc->resource_type == WINED3D_RTYPE_TEXTURE_3D)
+        depth_or_layer_count = desc->depth;
+    else
+        depth_or_layer_count = layer_count;
+
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            FIELD_OFFSET(struct wined3d_texture, sub_resources[level_count * layer_count]))))
+            FIELD_OFFSET(struct wined3d_texture, sub_resources[level_count * depth_or_layer_count]))))
         return E_OUTOFMEMORY;
 
     switch (desc->resource_type)
diff -ur a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
--- a/dlls/wined3d/utils.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/utils.c	2017-07-17 13:28:51.127409567 +0200
@@ -1925,7 +1925,7 @@
         case WINED3D_GL_RES_TYPE_TEX_RECT:
             return GL_TEXTURE_RECTANGLE_ARB;
         case WINED3D_GL_RES_TYPE_BUFFER:
-            return GL_TEXTURE_2D; /* TODO: GL_TEXTURE_BUFFER. */
+            return GL_TEXTURE_BUFFER;
         case WINED3D_GL_RES_TYPE_RB:
             return GL_RENDERBUFFER;
         case WINED3D_GL_RES_TYPE_COUNT:
diff -ur a/dlls/wined3d/view.c b/dlls/wined3d/view.c
--- a/dlls/wined3d/view.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/view.c	2017-07-17 13:28:51.127409567 +0200
@@ -557,8 +557,7 @@
         struct wined3d_texture *texture = texture_from_resource(resource);
 
         view->sub_resource_idx = desc->u.texture.level_idx;
-        if (resource->type != WINED3D_RTYPE_TEXTURE_3D)
-            view->sub_resource_idx += desc->u.texture.layer_idx * texture->level_count;
+        view->sub_resource_idx += desc->u.texture.layer_idx * texture->level_count;
         view->layer_count = desc->u.texture.layer_count;
         view->width = wined3d_texture_get_level_width(texture, desc->u.texture.level_idx);
         view->height = wined3d_texture_get_level_height(texture, desc->u.texture.level_idx);
diff -ur a/dlls/wined3d/wined3d_gl.h b/dlls/wined3d/wined3d_gl.h
--- a/dlls/wined3d/wined3d_gl.h	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/wined3d_gl.h	2017-07-17 13:28:51.127409567 +0200
@@ -43,6 +43,7 @@
     APPLE_FLUSH_BUFFER_RANGE,
     APPLE_YCBCR_422,
     /* ARB */
+    ARB_BASE_INSTANCE,
     ARB_BLEND_FUNC_EXTENDED,
     ARB_CLEAR_BUFFER_OBJECT,
     ARB_CLEAR_TEXTURE,
@@ -151,6 +152,7 @@
     EXT_FRAMEBUFFER_BLIT,
     EXT_FRAMEBUFFER_MULTISAMPLE,
     EXT_FRAMEBUFFER_OBJECT,
+    EXT_GEOMETRY_SHADER4,
     EXT_GPU_PROGRAM_PARAMETERS,
     EXT_GPU_SHADER4,
     EXT_PACKED_DEPTH_STENCIL,
diff -ur a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
--- a/dlls/wined3d/wined3d_private.h	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/wined3d/wined3d_private.h	2017-07-17 13:28:51.127409567 +0200
@@ -260,9 +260,10 @@
 /* Device caps */
 #define MAX_STREAMS                 16
 #define MAX_TEXTURES                8
-#define MAX_FRAGMENT_SAMPLERS       16
-#define MAX_VERTEX_SAMPLERS         4
-#define MAX_COMBINED_SAMPLERS       (MAX_FRAGMENT_SAMPLERS + MAX_VERTEX_SAMPLERS)
+#define MAX_FRAGMENT_SAMPLERS       32
+#define MAX_GEOMETRY_SAMPLERS       16
+#define MAX_VERTEX_SAMPLERS         32
+#define MAX_COMBINED_SAMPLERS       (MAX_FRAGMENT_SAMPLERS + MAX_GEOMETRY_SAMPLERS + MAX_VERTEX_SAMPLERS)
 #define MAX_ACTIVE_LIGHTS           8
 #define MAX_CLIP_DISTANCES          WINED3DMAXUSERCLIPPLANES
 #define MAX_CONSTANT_BUFFERS        15
@@ -439,6 +440,7 @@
 #define WINED3D_SHADER_CONST_FFP_LIGHTS      0x00080000
 #define WINED3D_SHADER_CONST_FFP_PS          0x00100000
 #define WINED3D_SHADER_CONST_FFP_COLOR_KEY   0x00200000
+#define WINED3D_SHADER_CONST_BASE_VERTEX     0x00400000
 
 enum wined3d_shader_register_type
 {
@@ -1336,7 +1338,8 @@
     DWORD flatshading : 1;
     DWORD alpha_test_func : 3;
     DWORD render_offscreen : 1;
-    DWORD padding : 26;
+    DWORD dual_source_blend : 1;
+    DWORD padding : 25;
 };
 
 enum fog_src_type {
@@ -1355,6 +1358,7 @@
     BYTE padding : 1;
     WORD swizzle_map;   /* MAX_ATTRIBS, 16 */
     unsigned int next_shader_input_count;
+    enum wined3d_shader_interpolation_mode interpolation_mode[MAX_REG_INPUT];
 };
 
 struct ds_compile_args
@@ -1365,11 +1369,13 @@
     unsigned int next_shader_type : 3;
     unsigned int render_offscreen : 1;
     unsigned int padding : 12;
+    enum wined3d_shader_interpolation_mode interpolation_mode[MAX_REG_INPUT];
 };
 
 struct gs_compile_args
 {
     unsigned int output_count;
+    enum wined3d_shader_interpolation_mode interpolation_mode[MAX_REG_INPUT];
 };
 
 struct wined3d_context;
@@ -3624,8 +3630,14 @@
 {
     struct wined3d_texture *texture;
 
-    if (!view || view->resource->type != WINED3D_RTYPE_TEXTURE_2D)
+    if (!view || (view->resource->type != WINED3D_RTYPE_TEXTURE_2D &&
+            view->resource->type != WINED3D_RTYPE_TEXTURE_3D &&
+            view->resource->type != WINED3D_RTYPE_TEXTURE_1D))
+    {
+        if (view)
+            DPRINTF("wined3d_rendertarget_view_get_surface: view->resource->type %d != WINED3D_RTYPE_TEXTURE_2D\n", view->resource->type);
         return NULL;
+    }
 
     texture = texture_from_resource(view->resource);
 
@@ -3797,6 +3809,20 @@
         const struct wined3d_state *state, DWORD state_id) DECLSPEC_HIDDEN;
 void state_shademode(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id) DECLSPEC_HIDDEN;
+static inline BOOL state_is_dual_source_blend(const struct wined3d_state *state)
+{
+#define IS_DUAL_SOURCE_BLEND(x) ((x) >= WINED3D_BLEND_SRC1COLOR && (x) <= WINED3D_BLEND_INVSRC1ALPHA)
+    if (state->render_states[WINED3D_RS_ALPHABLENDENABLE] &&
+            (IS_DUAL_SOURCE_BLEND(state->render_states[WINED3D_RS_SRCBLENDALPHA]) ||
+             IS_DUAL_SOURCE_BLEND(state->render_states[WINED3D_RS_DESTBLENDALPHA])))
+    {
+        return TRUE;
+    }
+
+    return IS_DUAL_SOURCE_BLEND(state->render_states[WINED3D_RS_SRCBLEND]) ||
+            IS_DUAL_SOURCE_BLEND(state->render_states[WINED3D_RS_DESTBLEND]);
+#undef IS_DUAL_SOURCE_BLEND
+}
 
 GLenum gl_primitive_type_from_d3d(enum wined3d_primitive_type primitive_type) DECLSPEC_HIDDEN;
 
@@ -3894,6 +3920,7 @@
     /* Pixel shader input semantics */
     DWORD input_reg_map[MAX_REG_INPUT];
     DWORD input_reg_used; /* MAX_REG_INPUT, 32 */
+    enum wined3d_shader_interpolation_mode interpolation_mode[MAX_REG_INPUT];
     unsigned int declared_in_count;
 
     /* Some information about the shader behavior */
@@ -4223,6 +4250,11 @@
     return !!state->shader[WINED3D_SHADER_TYPE_PIXEL];
 }
 
+static inline BOOL use_gs(const struct wined3d_state *state)
+{
+    return !!state->shader[WINED3D_SHADER_TYPE_GEOMETRY];
+}
+
 static inline void context_apply_state(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id)
 {
@@ -4274,8 +4306,8 @@
 
 static inline void wined3d_from_cs(struct wined3d_cs *cs)
 {
-    if (cs->thread)
-        assert(cs->thread_id == GetCurrentThreadId());
+    //if (cs->thread)
+        //assert(cs->thread_id == GetCurrentThreadId());
 }
 
 static inline void wined3d_not_from_cs(struct wined3d_cs *cs)
diff -ur a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
--- a/dlls/ws2_32/socket.c	2017-07-12 03:17:59.000000000 +0200
+++ b/dlls/ws2_32/socket.c	2017-07-17 13:28:51.164075935 +0200
@@ -5957,6 +5957,10 @@
             break;
 #endif
 
+        case WS_SO_RANDOMIZE_PORT:
+            FIXME("SO_RANDOMIZE_PORT: %x\n", *(uint16_t*)optval);
+            return 0;
+
         default:
             TRACE("Unknown SOL_SOCKET optname: 0x%08x\n", optname);
             SetLastError(WSAENOPROTOOPT);
Only in /home/gyaru/projects/wine-overwatch: .git
Only in /home/gyaru/projects/wine-overwatch: .gitignore
diff -ur a/include/bcrypt.h b/include/bcrypt.h
--- a/include/bcrypt.h	2017-07-12 03:17:59.000000000 +0200
+++ b/include/bcrypt.h	2017-07-17 13:28:51.284074956 +0200
@@ -40,6 +40,8 @@
 typedef LONG NTSTATUS;
 #endif
 
+#define BCRYPT_KEY_DATA_BLOB (const WCHAR []){'K','e','y','D','a','t','a','B','l','o','b',0}
+
 #define BCRYPT_ALGORITHM_NAME (const WCHAR []){'A','l','g','o','r','i','t','h','m','N','a','m','e',0}
 #define BCRYPT_AUTH_TAG_LENGTH (const WCHAR []){'A','u','t','h','T','a','g','L','e','n','g','t','h',0}
 #define BCRYPT_BLOCK_LENGTH (const WCHAR []){'B','l','o','c','k','L','e','n','g','t','h',0}
@@ -129,6 +131,13 @@
 /* Flags for BCryptEncrypt/BCryptDecrypt */
 #define BCRYPT_BLOCK_PADDING        0x00000001
 
+typedef struct _BCRYPT_KEY_DATA_BLOB_HEADER
+{
+    ULONG dwMagic;
+    ULONG dwVersion;
+    ULONG cbKeyData;
+} BCRYPT_KEY_DATA_BLOB_HEADER, *PBCRYPT_KEY_DATA_BLOB_HEADER;
+
 NTSTATUS WINAPI BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE, ULONG);
 NTSTATUS WINAPI BCryptCreateHash(BCRYPT_ALG_HANDLE, BCRYPT_HASH_HANDLE *, PUCHAR, ULONG, PUCHAR, ULONG, ULONG);
 NTSTATUS WINAPI BCryptDecrypt(BCRYPT_KEY_HANDLE, PUCHAR, ULONG, VOID *, PUCHAR, ULONG, PUCHAR, ULONG, ULONG *, ULONG);
Only in b/include: config.h.in~
diff -ur a/include/winsock.h b/include/winsock.h
--- a/include/winsock.h	2017-07-12 03:17:59.000000000 +0200
+++ b/include/winsock.h	2017-07-17 13:28:51.334074548 +0200
@@ -664,6 +664,7 @@
 #define SO_TYPE                    0x1008
 #define SO_BSP_STATE               0x1009
 
+#define SO_RANDOMIZE_PORT          0x3005
 
 #define IOCPARM_MASK               0x7f
 #define IOC_VOID                   0x20000000
@@ -699,6 +700,8 @@
 #define WS_SO_TYPE                 0x1008
 #define WS_SO_BSP_STATE            0x1009
 
+#define WS_SO_RANDOMIZE_PORT       0x3005
+
 #define WS_IOCPARM_MASK            0x7f
 #define WS_IOC_VOID                0x20000000
 #define WS_IOC_OUT                 0x40000000
diff -ur a/libs/wine/config.c b/libs/wine/config.c
--- a/libs/wine/config.c	2017-07-12 03:17:59.000000000 +0200
+++ b/libs/wine/config.c	2017-07-17 13:28:51.357407691 +0200
@@ -633,9 +633,6 @@
 }
 wine_patch_data[] =
 {
-    { "Alex Henrie", "mountmgr.sys: Do a device check before returning a default serial port name.", 1 },
-    { "Alex Henrie", "winex11: Send SC_KEYMENU on managed windows.", 1 },
-    { "Alex Villacís Lasso", "user.exe16: Fix handling of DDL_DRIVES flag in DlgDirList.", 1 },
     { "Alexander E. Patrakov", "dsound: Add a linear resampler for use with a large number of mixing buffers.", 2 },
     { "Alexander Morozov", "ntoskrnl.exe: Add stub for ObReferenceObjectByPointer.", 1 },
     { "Alexander Morozov", "ntoskrnl.exe: Add stubs for ExAcquireFastMutexUnsafe and ExReleaseFastMutexUnsafe.", 1 },
@@ -643,29 +640,31 @@
     { "Alexander Morozov", "ntoskrnl.exe: Improve KeInitializeSemaphore stub.", 1 },
     { "Alexander Morozov", "ntoskrnl.exe: Improve KeInitializeTimerEx stub.", 1 },
     { "Alexander Morozov", "ntoskrnl.exe: Improve KeReleaseMutex stub.", 1 },
+    { "Alex Henrie", "mountmgr.sys: Do a device check before returning a default serial port name.", 1 },
+    { "Alex Henrie", "winex11: Send SC_KEYMENU on managed windows.", 1 },
+    { "Alex Villacís Lasso", "user.exe16: Fix handling of DDL_DRIVES flag in DlgDirList.", 1 },
     { "Alistair Leslie-Hughes", "comctl32/tooltip: Protect TTM_ADDTOOLW from invalid text pointers.", 1 },
-    { "Alistair Leslie-Hughes", "d3dx9: Implement D3DXComputeTangent.", 1 },
     { "Alistair Leslie-Hughes", "d3dx9_36: ID3DXFont_DrawText calc_rect can be null.", 1 },
     { "Alistair Leslie-Hughes", "d3dx9_36: Implement D3DXGetShaderOutputSemantics.", 2 },
     { "Alistair Leslie-Hughes", "d3dx9_36: Return a mesh in D3DXCreateTeapot.", 1 },
     { "Alistair Leslie-Hughes", "d3dx9_36: Support NULL terminated strings in ID3DXFont_DrawText.", 1 },
+    { "Alistair Leslie-Hughes", "d3dx9: Implement D3DXComputeTangent.", 1 },
     { "Alistair Leslie-Hughes", "oleaut32: Implement semi-stub for CreateTypeLib.", 1 },
+    { "André Hentschel", "sfnt2fon: Don't leak output name if specified multiple times (Coverity).", 1 },
+    { "André Hentschel", "winedump: Free debug string in case it was not freed in for-loop (Coverity).", 1 },
+    { "André Hentschel", "wpcap: Load libpcap dynamically.", 1 },
     { "Andrew Wesie", "advapi32: Implement BuildSecurityDescriptorW.", 1 },
     { "Andrew Wesie", "bcrypt: Fix BCryptEncrypt with AES_GCM and no input and no output.", 1 },
-    { "Andrew Wesie", "ntdll/tests: Test updating TickCount in user_shared_data.", 1 },
     { "Andrew Wesie", "ntdll: Implement NtCreateThreadEx.", 1 },
+    { "Andrew Wesie", "ntdll/tests: Test updating TickCount in user_shared_data.", 1 },
     { "Andrew Wesie", "ntdll: TokenIntegrityLevel stub in NtSetInformationToken.", 1 },
     { "Andrew Wesie", "ntdll: TokenLogonSid stub in NtQueryInformationToken.", 1 },
     { "Andrey Gusev", "d3dx9_36: Add D3DXFrameFind stub.", 1 },
-    { "André Hentschel", "sfnt2fon: Don't leak output name if specified multiple times (Coverity).", 1 },
-    { "André Hentschel", "winedump: Free debug string in case it was not freed in for-loop (Coverity).", 1 },
-    { "André Hentschel", "wpcap: Load libpcap dynamically.", 1 },
     { "Austin English", "wininet: Add ParseX509EncodedCertificateForListBoxEntry stub.", 2 },
     { "Bernhard Reiter", "imagehlp: Implement parts of BindImageEx to make freezing Python scripts work.", 1 },
     { "Charles Davis", "crypt32: Skip unknown item when decoding a CMS certificate.", 1 },
     { "Christian Costa", "crypt32: Print CryptUnprotectMemory FIXME only once.", 1 },
     { "Christian Costa", "d3d9/tests: Avoid crash when surface and texture creation fails.", 1 },
-    { "Christian Costa", "d3dx9_36/tests: Add additional tests for special cases.", 1 },
     { "Christian Costa", "d3dx9_36: Add dxtn support.", 1 },
     { "Christian Costa", "d3dx9_36: Add format description for X8L8V8U8 for format conversions.", 1 },
     { "Christian Costa", "d3dx9_36: Add stub for D3DXComputeNormalMap.", 1 },
@@ -681,6 +680,7 @@
     { "Christian Costa", "d3dx9_36: Improve D3DXSaveTextureToFile to save simple texture to dds file.", 1 },
     { "Christian Costa", "d3dx9_36: No need to fail if we don't support vertices reordering in D3DXMESHOPT_ATTRSORT.", 1 },
     { "Christian Costa", "d3dx9_36: Recognize bump luminance X8L8V8U8 when loading dds file.", 1 },
+    { "Christian Costa", "d3dx9_36/tests: Add additional tests for special cases.", 1 },
     { "Christian Costa", "ddraw: Silence noisy FIXME about unimplemented D3DPROCESSVERTICES_UPDATEEXTENTS.", 1 },
     { "Christian Costa", "ntdll: Add dll override default rule for purist mode.", 1 },
     { "Christian Costa", "ntoskrnl.exe: Fix IoReleaseCancelSpinLock argument.", 1 },
@@ -692,25 +692,21 @@
     { "Christian Costa", "wined3d: Recognize GTX 560M card with NVIDIA driver.", 1 },
     { "Claudio Fontana", "kernel32: Allow empty profile section and key name strings.", 1 },
     { "Daniel Jelinski", "wine.inf: Add registry keys for Windows Performance Library.", 1 },
-    { "Dmitry Timoshkov", "advapi32/tests: Add a test that compares a well-known SID to a SID created from a SDDL abbreviation.", 1 },
-    { "Dmitry Timoshkov", "advapi32/tests: Add more tests for performance counters.", 1 },
     { "Dmitry Timoshkov", "advapi32: Add initial support for querying performance counters data.", 2 },
     { "Dmitry Timoshkov", "advapi32: If the query is not specified the default query is \"Global\".", 1 },
     { "Dmitry Timoshkov", "advapi32: Performance providers' Open() expects to see the configured name as its parameter.", 1 },
     { "Dmitry Timoshkov", "advapi32: Read the configured object list for the performance provider.", 1 },
     { "Dmitry Timoshkov", "advapi32: SDDL assigns the \"AC\" abbreviation to WinBuiltinAnyPackageSid.", 1 },
+    { "Dmitry Timoshkov", "advapi32/tests: Add a test that compares a well-known SID to a SID created from a SDDL abbreviation.", 1 },
+    { "Dmitry Timoshkov", "advapi32/tests: Add more tests for performance counters.", 1 },
     { "Dmitry Timoshkov", "avifil32: Add support for AVIFile interface proxies.", 2 },
     { "Dmitry Timoshkov", "comdlg32: Postpone setting ofn->lpstrFileTitle to work around an application bug.", 1 },
+    { "Dmitry Timoshkov", "gdi32: ExtTextOut on a path with bitmap font selected shouldn't fail.", 1 },
+    { "Dmitry Timoshkov", "gdi32: Improve detection of symbol charset for old truetype fonts.", 1 },
     { "Dmitry Timoshkov", "gdi32/tests: Add a simple test for printing to a PostScript device.", 1 },
     { "Dmitry Timoshkov", "gdi32/tests: Add some additional tests for ExtExtOut on a path for an EMF DC.", 2 },
     { "Dmitry Timoshkov", "gdi32/tests: Explicitly test BeginPath() return value in the metafile path tests.", 1 },
-    { "Dmitry Timoshkov", "gdi32: ExtTextOut on a path with bitmap font selected shouldn't fail.", 1 },
-    { "Dmitry Timoshkov", "gdi32: Improve detection of symbol charset for old truetype fonts.", 1 },
     { "Dmitry Timoshkov", "gdi32: Trace full contents of DOCINFO in StartDoc.", 1 },
-    { "Dmitry Timoshkov", "gdiplus/tests: Add a test for image flags to PNG grayscale image tests.", 1 },
-    { "Dmitry Timoshkov", "gdiplus/tests: Add a test for loading PNG grayscale images.", 1 },
-    { "Dmitry Timoshkov", "gdiplus/tests: Add some tests for GdipInitializePalette.", 2 },
-    { "Dmitry Timoshkov", "gdiplus/tests: Add some tests for loading TIFF images in various color formats.", 1 },
     { "Dmitry Timoshkov", "gdiplus: Add support for more image color formats.", 1 },
     { "Dmitry Timoshkov", "gdiplus: Change multiplications by additions in the x/y scaler loops.", 1 },
     { "Dmitry Timoshkov", "gdiplus: Change the order of x/y loops in the scaler.", 1 },
@@ -722,15 +718,12 @@
     { "Dmitry Timoshkov", "gdiplus: Prefer using pre-multiplied ARGB data in the scaler.", 1 },
     { "Dmitry Timoshkov", "gdiplus: Remove ceilf/floorf calls from bilinear scaler.", 2 },
     { "Dmitry Timoshkov", "gdiplus: Set correct color space flags for grayscale images.", 1 },
+    { "Dmitry Timoshkov", "gdiplus/tests: Add a test for image flags to PNG grayscale image tests.", 1 },
+    { "Dmitry Timoshkov", "gdiplus/tests: Add a test for loading PNG grayscale images.", 1 },
+    { "Dmitry Timoshkov", "gdiplus/tests: Add some tests for GdipInitializePalette.", 2 },
+    { "Dmitry Timoshkov", "gdiplus/tests: Add some tests for loading TIFF images in various color formats.", 1 },
     { "Dmitry Timoshkov", "include: Add more definitions for performance counters.", 1 },
     { "Dmitry Timoshkov", "include: Make stdole32.idl a public component.", 1 },
-    { "Dmitry Timoshkov", "kernel32/tests: Add a PE test image that resembles format of some of 8k demos.", 1 },
-    { "Dmitry Timoshkov", "kernel32/tests: Add some tests for GetLongPathName/GetShortPathName called with a wildcard.", 1 },
-    { "Dmitry Timoshkov", "kernel32/tests: Add tests for NtQuerySection.", 2 },
-    { "Dmitry Timoshkov", "kernel32/tests: Fix a bunch of access denied errors by using a dedicated TEMP directory.", 1 },
-    { "Dmitry Timoshkov", "kernel32/tests: Fix a module reference leak leading to an undeletable temporary file.", 1 },
-    { "Dmitry Timoshkov", "kernel32/tests: Fix compilation with PSDK.", 1 },
-    { "Dmitry Timoshkov", "kernel32/tests: Move the MoveFile test where it belongs.", 1 },
     { "Dmitry Timoshkov", "kernel32: Add a bunch of kernel32 stubs.", 1 },
     { "Dmitry Timoshkov", "kernel32: GetLongPathName should fail when called with a wildcard.", 1 },
     { "Dmitry Timoshkov", "kernel32: GetShortPathName should fail when called with a wildcard.", 1 },
@@ -738,20 +731,26 @@
     { "Dmitry Timoshkov", "kernel32: MoveFile should make sure that it has the delete access to the source file.", 1 },
     { "Dmitry Timoshkov", "kernel32: MoveFile(source, source) should succeed.", 1 },
     { "Dmitry Timoshkov", "kernel32: On process entry store PEB address in %ebx.", 1 },
-    { "Dmitry Timoshkov", "libs/wine: Allow to modify reserved LDT entries.", 1 },
+    { "Dmitry Timoshkov", "kernel32/tests: Add a PE test image that resembles format of some of 8k demos.", 1 },
+    { "Dmitry Timoshkov", "kernel32/tests: Add some tests for GetLongPathName/GetShortPathName called with a wildcard.", 1 },
+    { "Dmitry Timoshkov", "kernel32/tests: Add tests for NtQuerySection.", 2 },
+    { "Dmitry Timoshkov", "kernel32/tests: Fix a bunch of access denied errors by using a dedicated TEMP directory.", 1 },
+    { "Dmitry Timoshkov", "kernel32/tests: Fix a module reference leak leading to an undeletable temporary file.", 1 },
+    { "Dmitry Timoshkov", "kernel32/tests: Fix compilation with PSDK.", 1 },
+    { "Dmitry Timoshkov", "kernel32/tests: Move the MoveFile test where it belongs.", 1 },
     { "Dmitry Timoshkov", "libs: Fix most problems with CompareString.", 1 },
-    { "Dmitry Timoshkov", "ntdll/tests: Add tests for NtQueryVirtualMemory(MemorySectionName).", 1 },
+    { "Dmitry Timoshkov", "libs/wine: Allow to modify reserved LDT entries.", 1 },
     { "Dmitry Timoshkov", "ntdll: Avoid race-conditions with write watches in NtReadFile.", 1 },
     { "Dmitry Timoshkov", "ntdll: If PE image size is larger than the backed file size then treat file as removable.", 1 },
     { "Dmitry Timoshkov", "ntdll: Implement NtQueryVirtualMemory(MemorySectionName).", 3 },
     { "Dmitry Timoshkov", "ntdll: Implement NtSetLdtEntries.", 1 },
     { "Dmitry Timoshkov", "ntdll: Reserve some more stack space in call_thread_func_wrapper.", 1 },
     { "Dmitry Timoshkov", "ntdll: Split logic for MemoryBasicInformation into a separate function.", 1 },
-    { "Dmitry Timoshkov", "ole32/tests: Add a bunch of tests for HGLOBAL based IStream::Clone.", 1 },
+    { "Dmitry Timoshkov", "ntdll/tests: Add tests for NtQueryVirtualMemory(MemorySectionName).", 1 },
     { "Dmitry Timoshkov", "ole32: Add a check for hglobal pointer to GetHGlobalFromStream.", 1 },
     { "Dmitry Timoshkov", "ole32: Add a wrapper for memory block managed by HGLOBAL based IStream.", 1 },
     { "Dmitry Timoshkov", "ole32: Allow moving a being reallocated block of memory managed by HGLOBAL based IStream.", 1 },
-    { "Dmitry Timoshkov", "oleaut32/tests: Add some tests for loading and saving EMF using IPicture interface.", 1 },
+    { "Dmitry Timoshkov", "ole32/tests: Add a bunch of tests for HGLOBAL based IStream::Clone.", 1 },
     { "Dmitry Timoshkov", "oleaut32: Accept DISP_E_PARAMNOTFOUND for missing optional parameters in ITypeInfo::Invoke implementation.", 3 },
     { "Dmitry Timoshkov", "oleaut32: Add support for decoding SLTG function help strings.", 1 },
     { "Dmitry Timoshkov", "oleaut32: Add support for decoding SLTG variable help strings.", 1 },
@@ -761,35 +760,26 @@
     { "Dmitry Timoshkov", "oleaut32: Factor out stream creation from OleLoadPicturePath.", 1 },
     { "Dmitry Timoshkov", "oleaut32: Fix calling function with instance and VARIANT return type.", 2 },
     { "Dmitry Timoshkov", "oleaut32: Fix logic for deciding whether type description follows the name.", 2 },
-    { "Dmitry Timoshkov", "oleaut32: Implement OleLoadPictureFile.", 2 },
     { "Dmitry Timoshkov", "oleaut32: Implement a better stub for IPicture::SaveAsFile.", 1 },
     { "Dmitry Timoshkov", "oleaut32: Implement decoding of SLTG help strings.", 1 },
+    { "Dmitry Timoshkov", "oleaut32: Implement OleLoadPictureFile.", 2 },
     { "Dmitry Timoshkov", "oleaut32: Make OleLoadPicture load DIBs using WIC decoder.", 1 },
     { "Dmitry Timoshkov", "oleaut32: OleLoadPicture should create a DIB section for a being loaded bitmap.", 3 },
+    { "Dmitry Timoshkov", "oleaut32/tests: Add some tests for loading and saving EMF using IPicture interface.", 1 },
     { "Dmitry Timoshkov", "riched20/tests: Add a test to see what richedit class flavours should be available.", 1 },
     { "Dmitry Timoshkov", "server: Add support for a layered window region.", 2 },
     { "Dmitry Timoshkov", "server: All fields up to CheckSum are mandatory regardless of SizeOfOptionalHeader value.", 1 },
     { "Dmitry Timoshkov", "server: CreateFileMapping should not fail without SEC_COMMIT for a named file section.", 1 },
-    { "Dmitry Timoshkov", "setupapi/tests: Add more tests for SPFILENOTIFY_FILEINCABINET handler.", 1 },
     { "Dmitry Timoshkov", "setupapi: Fix parameters of SPFILENOTIFY_FILEINCABINET handler.", 1 },
+    { "Dmitry Timoshkov", "setupapi/tests: Add more tests for SPFILENOTIFY_FILEINCABINET handler.", 1 },
     { "Dmitry Timoshkov", "shell32: Add more Tango icons to the IE toolbar.", 1 },
     { "Dmitry Timoshkov", "shell32: Add toolbar bitmaps compatible with IE6.", 1 },
     { "Dmitry Timoshkov", "shell32: Implement SHCreateSessionKey.", 1 },
     { "Dmitry Timoshkov", "tools/wrc: Fix generation of custom dialog control data.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Add a bunch of tests for DM_SETDEFID/DM_GETDEFID handling by a DefDlgProc.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Add a focus test for an empty dialog that returns TRUE in WM_INITDIALOG.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Add a message test for an owner-drawn sorted listbox.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Add a message test for group of radio buttons.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Add a test for WM_MEASUREITEM when inserting an item to an owner-drawn listbox.", 2 },
-    { "Dmitry Timoshkov", "user32/tests: Add a test for custom dialog control data.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Add a test for navigating a group of buttons using keyboard events.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Add some tests to see when MessageBox gains WS_EX_TOPMOST style.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Simplify the test for BM_CLICK on autoradio button by using a dialog.", 1 },
-    { "Dmitry Timoshkov", "user32/tests: Test DialogBoxParam using a dialog template with invalid control class.", 1 },
     { "Dmitry Timoshkov", "user32: Add a check if the menu text is a valid string.", 1 },
     { "Dmitry Timoshkov", "user32: Add a workaround for Windows 3.1 apps which call LoadImage(LR_LOADFROMFILE) with a resource id.", 2 },
-    { "Dmitry Timoshkov", "user32: Add support for PNG icons.", 5 },
     { "Dmitry Timoshkov", "user32: Add support for navigating a group of radio buttons using a keyboard.", 1 },
+    { "Dmitry Timoshkov", "user32: Add support for PNG icons.", 5 },
     { "Dmitry Timoshkov", "user32: Always restore previously selected font in the button painting helpers.", 1 },
     { "Dmitry Timoshkov", "user32: Before asking a WM to activate a window make sure that the window is in foreground and not minimized.", 1 },
     { "Dmitry Timoshkov", "user32: DialogBoxParam should return -1 when dialog control creation fails.", 1 },
@@ -804,17 +794,27 @@
     { "Dmitry Timoshkov", "user32: MessageBox should be topmost when MB_SYSTEMMODAL style is set.", 1 },
     { "Dmitry Timoshkov", "user32: Move the auto radio button group logic from BM_SETCHECK to WM_LBUTTONUP handler.", 1 },
     { "Dmitry Timoshkov", "user32: Pass correct itemData to WM_MEASUREITEM when inserting an item to an owner-drawn listbox.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Add a bunch of tests for DM_SETDEFID/DM_GETDEFID handling by a DefDlgProc.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Add a focus test for an empty dialog that returns TRUE in WM_INITDIALOG.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Add a message test for an owner-drawn sorted listbox.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Add a message test for group of radio buttons.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Add a test for custom dialog control data.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Add a test for navigating a group of buttons using keyboard events.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Add a test for WM_MEASUREITEM when inserting an item to an owner-drawn listbox.", 2 },
+    { "Dmitry Timoshkov", "user32/tests: Add some tests to see when MessageBox gains WS_EX_TOPMOST style.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Simplify the test for BM_CLICK on autoradio button by using a dialog.", 1 },
+    { "Dmitry Timoshkov", "user32/tests: Test DialogBoxParam using a dialog template with invalid control class.", 1 },
     { "Dmitry Timoshkov", "user32: Try harder to find a target for mouse messages.", 1 },
     { "Dmitry Timoshkov", "user32: Use root dialog for DM_SETDEFID/DM_GETDEFID in DefDlgProc.", 1 },
     { "Dmitry Timoshkov", "uxtheme: Protect CloseThemeData() from invalid input.", 1 },
     { "Dmitry Timoshkov", "widl: Add initial implementation of SLTG typelib generator.", 1 },
-    { "Dmitry Timoshkov", "widl: Add support for VT_USERDEFINED to SLTG typelib generator.", 1 },
-    { "Dmitry Timoshkov", "widl: Add support for VT_VOID and VT_VARIANT to SLTG typelib generator.", 1 },
     { "Dmitry Timoshkov", "widl: Add support for function parameter flags to SLTG typelib generator.", 1 },
     { "Dmitry Timoshkov", "widl: Add support for inherited interfaces to SLTG typelib generator.", 1 },
     { "Dmitry Timoshkov", "widl: Add support for interfaces to SLTG typelib generator.", 1 },
     { "Dmitry Timoshkov", "widl: Add support for recursive type references to SLTG typelib generator.", 1 },
     { "Dmitry Timoshkov", "widl: Add support for structures.", 1 },
+    { "Dmitry Timoshkov", "widl: Add support for VT_USERDEFINED to SLTG typelib generator.", 1 },
+    { "Dmitry Timoshkov", "widl: Add support for VT_VOID and VT_VARIANT to SLTG typelib generator.", 1 },
     { "Dmitry Timoshkov", "widl: Avoid relying on side effects when marking function index as the last one.", 1 },
     { "Dmitry Timoshkov", "widl: Calculate size of instance for structures.", 1 },
     { "Dmitry Timoshkov", "widl: Create library block index right after the CompObj one.", 1 },
@@ -825,35 +825,23 @@
     { "Dmitry Timoshkov", "widl: More accurately report variable descriptions data size.", 1 },
     { "Dmitry Timoshkov", "widl: Properly align name table entries.", 1 },
     { "Dmitry Timoshkov", "widl: Set the lowest bit in the param name to indicate whether type description follows the name.", 1 },
-    { "Dmitry Timoshkov", "widl: Write SLTG blocks according to the index order.", 1 },
     { "Dmitry Timoshkov", "widl: Write correct syskind by SLTG typelib generator.", 1 },
     { "Dmitry Timoshkov", "widl: Write correct typekind to the SLTG typeinfo block.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add a bunch of new tests for indexed format conversions.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add a missing check for IWICBitmapFrameDecode::GetPixelFormat return value.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add a test for 8bpp indexed TIFF format.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add a test for loading PNG grayscale images.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add more tests for loading PNG images in various color formats.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add some tests for IWICPalette::InitializeFromBitmap.", 2 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add some tests for converting 24bppBGR to 8bppIndexed format.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add some tests for encoding 1bpp/8bpp images with a palette.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add tests for encoding 2bpp/4bpp images with a palette.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Add the tests for GIF encoder and decoder.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Make create_decoder() return an error code in PNG tests.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs/tests: Make the test for 8bpp indexed TIFF format run under XP.", 1 },
+    { "Dmitry Timoshkov", "widl: Write SLTG blocks according to the index order.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add initial implementation of the GIF encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add registration for GUID_WICPixelFormat32bppGrayFloat pixel format.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add registration of the GIF encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add some tests for various TIFF color formats.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for 128bppRGBAFloat format to TIFF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for 12bpp RGB format to TIFF decoder.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs: Add support for 16bpp RGBA format to TIFF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for 16bppGray and 32bppGrayFloat formats to TIFF decoder.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs: Add support for 16bpp RGBA format to TIFF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for 32bppCMYK and 64bppCMYK formats to TIFF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for 32bppRGB, 32bppRGBA and 32bppPRGBA to format converter.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for 3bps RGB format to TIFF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for 4bpp RGBA format to TIFF decoder.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs: Add support for IMILBitmapScaler interface.", 2 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for converting to 8bppIndexed format to IWICFormatConverter.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs: Add support for IMILBitmapScaler interface.", 2 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for palette image formats to BMP encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for palette image formats to PNG encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Add support for palette image formats to TIFF encoder.", 1 },
@@ -867,21 +855,21 @@
     { "Dmitry Timoshkov", "windowscodecs: Find_decoder() should return an error it received from the decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Fix 32bppGrayFloat to 8bppGray conversion.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Fix 32bppRGB to 32bppRGBA conversion.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs: Fix behaviour of format converter for indexed formats when NULL or empty palette has been provided.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Fix IWICBitmapDecoder::CopyPalette for a not initialized case in the GIF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Fix IWICBitmapEncoder::SetPalette for a not initialized case in BMP encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Fix IWICBitmapEncoder::SetPalette for a not initialized case in PNG encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Fix IWICBitmapEncoder::SetPalette for a not initialized case in TIFF encoder.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs: Fix behaviour of format converter for indexed formats when NULL or empty palette has been provided.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs: Fix the SupportsTransparency flag value for various pixel formats.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Fix the buffer size check in the TIFF decoder's IWICBitmapFrameDecode::CopyPixels implementation.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs: Fix the SupportsTransparency flag value for various pixel formats.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapDecoder::CopyPalette in PNG decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapDecoder::CopyPalette in TIFF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapDecoder::GetMetadataQueryReader in the TIFF decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapEncoder::GetEncoderInfo in BMP encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapEncoder::GetEncoderInfo in JPEG encoder.", 1 },
-    { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapEncoder::GetEncoderInfo in TIFF encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapEncoder::GetEncoderInfo in the JPEG encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapEncoder::GetEncoderInfo in the PNG encoder.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapEncoder::GetEncoderInfo in TIFF encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapEncoderInfo::GetFileExtensions.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapFrameEncode::SetPalette in BMP encoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Implement IWICBitmapFrameEncode::SetPalette in JPEG encoder,.", 1 },
@@ -894,6 +882,18 @@
     { "Dmitry Timoshkov", "windowscodecs: Limit number of colors in a palette in BMP decoder.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: PNG decoder should return WINCODEC_ERR_UNKNOWNIMAGEFORMAT when image loading fails.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: PNG decoder should use indexed formats for grayscale images when a PLTE chunk exists.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add a bunch of new tests for indexed format conversions.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add a missing check for IWICBitmapFrameDecode::GetPixelFormat return value.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add a test for 8bpp indexed TIFF format.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add a test for loading PNG grayscale images.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add more tests for loading PNG images in various color formats.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add some tests for converting 24bppBGR to 8bppIndexed format.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add some tests for encoding 1bpp/8bpp images with a palette.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add some tests for IWICPalette::InitializeFromBitmap.", 2 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add tests for encoding 2bpp/4bpp images with a palette.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Add the tests for GIF encoder and decoder.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Make create_decoder() return an error code in PNG tests.", 1 },
+    { "Dmitry Timoshkov", "windowscodecs/tests: Make the test for 8bpp indexed TIFF format run under XP.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Tolerate partial reads in the IFD metadata loader.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: Use V_UI1() instead of V_UNION() to assign a VT_UI1 variant member.", 1 },
     { "Dmitry Timoshkov", "windowscodecs: WICConvertBitmapSource should ask IWICFormatConverter::Initialize to use an optimized palette.", 1 },
@@ -909,25 +909,24 @@
     { "Dmitry Timoshkov", "winex11.drv: Send WM_WINDOWPOSCHANGING/WM_WINDOWPOSCHANGED messages to a being deactivated topmost window.", 1 },
     { "Dmitry Timoshkov", "winex11: Fix handling of window attributes for WS_EX_LAYERED | WS_EX_COMPOSITED.", 1 },
     { "Dmitry Timoshkov", "winspool.drv: Add performance counters service stubs.", 1 },
-    { "Erich E. Hoover", "Appease the blessed version of gcc (4.5) when -Werror is enabled.", 1 },
     { "Erich E. Hoover", "advapi32: Fix the initialization of combined DACLs when the new DACL is empty.", 1 },
     { "Erich E. Hoover", "advapi32: Move the DACL combining code into a separate routine.", 1 },
+    { "Erich E. Hoover", "Appease the blessed version of gcc (4.5) when -Werror is enabled.", 1 },
     { "Erich E. Hoover", "dsound: Add stub support for DSPROPSETID_EAX20_BufferProperties.", 1 },
     { "Erich E. Hoover", "dsound: Add stub support for DSPROPSETID_EAX20_ListenerProperties.", 1 },
     { "Erich E. Hoover", "fonts: Add WenQuanYi Micro Hei as a Microsoft Yahei replacement.", 1 },
     { "Erich E. Hoover", "iphlpapi: Implement AllocateAndGetTcpExTableFromStack.", 2 },
-    { "Erich E. Hoover", "kernel32,ntdll: Add support for deleting junction points with RemoveDirectory.", 1 },
     { "Erich E. Hoover", "kernel32: Add SearchPath test demonstrating the priority of the working directory.", 1 },
     { "Erich E. Hoover", "kernel32: Advertise junction point support.", 1 },
     { "Erich E. Hoover", "kernel32: Consider the working directory first when launching executables with CreateProcess.", 1 },
     { "Erich E. Hoover", "kernel32: NeedCurrentDirectoryForExePath does not use the registry.", 1 },
+    { "Erich E. Hoover", "kernel32,ntdll: Add support for deleting junction points with RemoveDirectory.", 1 },
     { "Erich E. Hoover", "libport: Add support for FreeBSD style extended attributes.", 1 },
     { "Erich E. Hoover", "libport: Add support for Mac OS X style extended attributes.", 1 },
     { "Erich E. Hoover", "msi: Add support for deleting streams from an MSI database.", 1 },
     { "Erich E. Hoover", "msi: Add support for exporting binary streams (Binary/Icon tables).", 1 },
     { "Erich E. Hoover", "msi: Add support for exporting the _SummaryInformation table.", 1 },
     { "Erich E. Hoover", "msi: Break out field exporting into a separate routine.", 1 },
-    { "Erich E. Hoover", "msi: Return an error when MsiDatabaseImport is passed an invalid pathname.", 1 },
     { "Erich E. Hoover", "msidb: Add stub tool for manipulating MSI databases.", 1 },
     { "Erich E. Hoover", "msidb: Add support for adding stream/cabinet files to MSI databases.", 1 },
     { "Erich E. Hoover", "msidb: Add support for exporting database tables.", 1 },
@@ -936,16 +935,17 @@
     { "Erich E. Hoover", "msidb: Add support for importing database tables.", 1 },
     { "Erich E. Hoover", "msidb: Add support for removing stream/cabinet files from MSI databases.", 1 },
     { "Erich E. Hoover", "msidb: Add support for wildcard (full database) export.", 1 },
-    { "Erich E. Hoover", "ntdll/tests: Add test for deleting junction point target.", 1 },
+    { "Erich E. Hoover", "msi: Return an error when MsiDatabaseImport is passed an invalid pathname.", 1 },
     { "Erich E. Hoover", "ntdll: Add a test for junction point advertisement.", 1 },
     { "Erich E. Hoover", "ntdll: Add support for deleting junction points.", 1 },
     { "Erich E. Hoover", "ntdll: Add support for junction point creation.", 1 },
     { "Erich E. Hoover", "ntdll: Add support for reading junction points.", 1 },
-    { "Erich E. Hoover", "ntdll: Implement retrieving DOS attributes in NtQueryInformationFile.", 1 },
     { "Erich E. Hoover", "ntdll: Implement retrieving DOS attributes in NtQuery[Full]AttributesFile and NtQueryDirectoryFile.", 1 },
+    { "Erich E. Hoover", "ntdll: Implement retrieving DOS attributes in NtQueryInformationFile.", 1 },
     { "Erich E. Hoover", "ntdll: Implement storing DOS attributes in NtCreateFile.", 1 },
     { "Erich E. Hoover", "ntdll: Implement storing DOS attributes in NtSetInformationFile.", 1 },
     { "Erich E. Hoover", "ntdll: Perform the Unix-style hidden file check within the unified file info grabbing routine.", 1 },
+    { "Erich E. Hoover", "ntdll/tests: Add test for deleting junction point target.", 1 },
     { "Erich E. Hoover", "quartz: Implement MediaSeeking_GetCurrentPosition on top of MediaSeeking_GetPositions.", 1 },
     { "Erich E. Hoover", "quartz: Implement MediaSeeking_GetStopPosition on top of MediaSeeking_GetPositions.", 1 },
     { "Erich E. Hoover", "quartz: Include the stream position in addition to the reference clock offset in the time returned by MediaSeeking_GetPositions.", 1 },
@@ -1009,12 +1009,12 @@
     { "Kimmo Myllyvirta", "xaudio2: Add support for float formats with more than 2 channels.", 1 },
     { "Louis Lenders", "include: Add headerfile virtdisk.h.", 1 },
     { "Louis Lenders", "ntdll: Improve stub for NtAllocateUuids.", 1 },
-    { "Mark Harmstone", "dsound: Add EAX VerbPass stub.", 1 },
+    { "Mark Harmstone", "dsound: Add delay line EAX functions.", 1 },
     { "Mark Harmstone", "dsound: Add EAX init and free stubs.", 1 },
     { "Mark Harmstone", "dsound: Add EAX presets.", 1 },
     { "Mark Harmstone", "dsound: Add EAX propset stubs.", 1 },
     { "Mark Harmstone", "dsound: Add EAX v1 constants and structs.", 1 },
-    { "Mark Harmstone", "dsound: Add delay line EAX functions.", 1 },
+    { "Mark Harmstone", "dsound: Add EAX VerbPass stub.", 1 },
     { "Mark Harmstone", "dsound: Allocate EAX delay lines.", 1 },
     { "Mark Harmstone", "dsound: Feed data through EAX function.", 1 },
     { "Mark Harmstone", "dsound: Implement EAX decorrelator.", 1 },
@@ -1029,8 +1029,8 @@
     { "Mark Harmstone", "winepulse: Expose audio devices directly to programs.", 1 },
     { "Mark Harmstone", "winepulse: Fetch actual program name if possible.", 1 },
     { "Mark Harmstone", "winepulse: Fix segfault in pulse_rd_loop.", 1 },
-    { "Mark Harmstone", "winepulse: Implement GetPropValue.", 1 },
     { "Mark Harmstone", "winepulse: Implement exclusive mode.", 1 },
+    { "Mark Harmstone", "winepulse: Implement GetPropValue.", 1 },
     { "Mark Harmstone", "winepulse: Return PKEY_AudioEndpoint_PhysicalSpeakers device prop.", 1 },
     { "Mark Jansen", "comctl32/tests: Prevent a possible nullpointer dereference.", 1 },
     { "Mark Jansen", "imagehlp/tests: Add tests for ImageLoad, ImageUnload, GetImageUnusedHeaderBytes.", 1 },
@@ -1041,19 +1041,19 @@
     { "Mark Jansen", "ntdll/tests: Tests for RtlIpv6StringToAddress.", 6 },
     { "Mark Jansen", "ntdll/tests: Tests for RtlIpv6StringToAddressEx.", 6 },
     { "Mark Jansen", "shell32: Properly fail when a data object cannot be instantiated and expand environment strings in ShellExecute.", 1 },
-    { "Mark Jansen", "shlwapi/tests: Add tests for AssocGetPerceivedType.", 1 },
     { "Mark Jansen", "shlwapi: Implement AssocGetPerceivedType.", 2 },
+    { "Mark Jansen", "shlwapi/tests: Add tests for AssocGetPerceivedType.", 1 },
     { "Mark Jansen", "version: Test for VerQueryValueA.", 2 },
     { "Mark Jansen", "wintrust/tests: Add tests for WinVerifyTrust.", 2 },
     { "Mark Jansen", "wintrust: Verify image hash in WinVerifyTrust.", 2 },
     { "Matt Durgavich", "ws2_32: Proper WSACleanup implementation using wineserver function.", 2 },
-    { "Michael Müller", "Add licenses for fonts as separate files.", 1 },
     { "Michael Müller", "aclui: Add basic ACE viewer.", 1 },
-    { "Michael Müller", "advapi32/tests: Add test for perflib registry key.", 1 },
+    { "Michael Müller", "Add licenses for fonts as separate files.", 1 },
     { "Michael Müller", "advapi32: Add stub for LsaLookupPrivilegeDisplayName.", 1 },
     { "Michael Müller", "advapi32: Fix error code when calling LsaOpenPolicy for non existing remote machine.", 1 },
     { "Michael Müller", "advapi32: Implement GetExplicitEntriesFromAclW.", 1 },
     { "Michael Müller", "advapi32: Implement LsaLookupPrivilegeName.", 1 },
+    { "Michael Müller", "advapi32/tests: Add test for perflib registry key.", 1 },
     { "Michael Müller", "advapi32: Use TRACE for LsaOpenPolicy/LsaClose.", 1 },
     { "Michael Müller", "api-ms-win-core-heap-l2-1-0: Add dll.", 1 },
     { "Michael Müller", "api-ms-win-core-shlwapi-obsolete-l1-2-0: Add dll.", 1 },
@@ -1065,7 +1065,6 @@
     { "Michael Müller", "avifil32: Correctly handle compressed frames when desired format is specified.", 1 },
     { "Michael Müller", "avifile.dll16: Convert between AVISTREAMINFO (16 bit) and AVISTREAMINFOA.", 1 },
     { "Michael Müller", "avifile.dll16: Correctly convert result of AVIStreamGetFrame to a segptr.", 1 },
-    { "Michael Müller", "bcrypt/tests: Add tests for AES GCM mode.", 1 },
     { "Michael Müller", "bcrypt: Add support for auth data in AES GCM mode.", 1 },
     { "Michael Müller", "bcrypt: Add support for computing/comparing cipher tag.", 1 },
     { "Michael Müller", "bcrypt: Allow to call BCryptSetProperty on key objects.", 1 },
@@ -1078,6 +1077,7 @@
     { "Michael Müller", "bcrypt: Implement BCryptGetProperty for BCRYPT_CHAINING_MODE.", 1 },
     { "Michael Müller", "bcrypt: Implement BCryptSetProperty for algorithms.", 1 },
     { "Michael Müller", "bcrypt: Properly handle padding in AES decryption.", 1 },
+    { "Michael Müller", "bcrypt/tests: Add tests for AES GCM mode.", 1 },
     { "Michael Müller", "browseui: Implement IProgressDialog::SetAnimation.", 1 },
     { "Michael Müller", "browseui: Implement PROGDLG_AUTOTIME flag for IProgressDialog.", 1 },
     { "Michael Müller", "combase: Add stub for CleanupTlsOleState.", 1 },
@@ -1091,18 +1091,6 @@
     { "Michael Müller", "crypt32: Add MS root CA 2010/2011.", 1 },
     { "Michael Müller", "crypt32: Properly check root certificate in CERT_CHAIN_REVOCATION_CHECK_CHAIN.", 1 },
     { "Michael Müller", "crypt32: Recognize sha256/384/512 KEY OIDs.", 1 },
-    { "Michael Müller", "d3d11/tests: Add more advanced CopySubresourceRegion tests.", 1 },
-    { "Michael Müller", "d3d11/tests: Add some basic 1d texture tests in test_texture.", 1 },
-    { "Michael Müller", "d3d11/tests: Add some basic depth tests.", 1 },
-    { "Michael Müller", "d3d11/tests: Add support for 1d textures in check_rtv_desc_.", 1 },
-    { "Michael Müller", "d3d11/tests: Add support for 1d textures in check_srv_desc_.", 1 },
-    { "Michael Müller", "d3d11/tests: Add test for creating 1d textures.", 1 },
-    { "Michael Müller", "d3d11/tests: Don't use draw_quad in test_cb_relative_addressing.", 1 },
-    { "Michael Müller", "d3d11/tests: Prepare test_texture for 1d textures.", 1 },
-    { "Michael Müller", "d3d11/tests: Prepare test_texture for non 2d textures.", 1 },
-    { "Michael Müller", "d3d11/tests: Test 1d texture interfaces.", 1 },
-    { "Michael Müller", "d3d11/tests: Test the creation of 1d render buffers in test_create_rendertarget_view.", 1 },
-    { "Michael Müller", "d3d11/tests: Test the creation of 1d shader resource views in test_create_shader_resource_view.", 1 },
     { "Michael Müller", "d3d11: Add a hack to prevent creation of 1d cube textures.", 1 },
     { "Michael Müller", "d3d11: Add d3d11_texture1d_SetPrivateDataInterface.", 1 },
     { "Michael Müller", "d3d11: Add stub ID3D11Texture2D and ID3D10Texture2D interfaces.", 1 },
@@ -1113,28 +1101,38 @@
     { "Michael Müller", "d3d11: Create a private store in d3d_texture1d_init.", 1 },
     { "Michael Müller", "d3d11: Create a texture in d3d_texture1d_init.", 1 },
     { "Michael Müller", "d3d11: Generate dxgi surface in d3d_texture1d_init.", 1 },
+    { "Michael Müller", "d3d11: Implement ClearDepthStencilView for deferred contexts.", 1 },
+    { "Michael Müller", "d3d11: Implement ClearRenderTargetView for deferred contexts.", 1 },
     { "Michael Müller", "d3d11: Implement CSSetConstantBuffers for deferred contexts.", 1 },
     { "Michael Müller", "d3d11: Implement CSSetShader for deferred contexts.", 1 },
     { "Michael Müller", "d3d11: Implement CSSetUnorderedAccessViews for deferred contexts.", 1 },
-    { "Michael Müller", "d3d11: Implement ClearDepthStencilView for deferred contexts.", 1 },
-    { "Michael Müller", "d3d11: Implement ClearRenderTargetView for deferred contexts.", 1 },
-    { "Michael Müller", "d3d11: Implement Dispatch for deferred contexts.", 1 },
-    { "Michael Müller", "d3d11: Implement Draw for deferred contexts.", 1 },
-    { "Michael Müller", "d3d11: Implement ResolveSubresource by copying sub resource (there is no multisample texture support yet).", 1 },
     { "Michael Müller", "d3d11: Implement d3d10_device_ResolveSubresource in the same way as for d3d11.", 1 },
-    { "Michael Müller", "d3d11: Implement d3d10_texture1d_(Un)map.", 1 },
     { "Michael Müller", "d3d11: Implement d3d10_texture1d_GetDesc.", 1 },
+    { "Michael Müller", "d3d11: Implement d3d10_texture1d_(Un)map.", 1 },
     { "Michael Müller", "d3d11: Implement d3d11_texture1d_{G,S}etPrivateData.", 1 },
     { "Michael Müller", "d3d11: Implement depth bias and slope.", 1 },
-    { "Michael Müller", "d3d11: Improve ID3D11Device_CheckFormatSupport.", 1 },
+    { "Michael Müller", "d3d11: Implement Dispatch for deferred contexts.", 1 },
+    { "Michael Müller", "d3d11: Implement Draw for deferred contexts.", 1 },
+    { "Michael Müller", "d3d11: Implement ResolveSubresource by copying sub resource (there is no multisample texture support yet).", 1 },
     { "Michael Müller", "d3d11: Improve d3d11_texture1d_GetDesc by obtaining the current width and format from wined3d.", 1 },
+    { "Michael Müller", "d3d11: Improve ID3D11Device_CheckFormatSupport.", 1 },
     { "Michael Müller", "d3d11: Initial implementation for deferred contexts.", 1 },
     { "Michael Müller", "d3d11: Prevent race condition when creating samplers.", 1 },
     { "Michael Müller", "d3d11: Silence ID3D11Device_GetDeviceRemovedReason.", 1 },
-    { "Michael Müller", "d3dx9_36/tests: Add initial tests for dummy skininfo interface.", 1 },
+    { "Michael Müller", "d3d11/tests: Add more advanced CopySubresourceRegion tests.", 1 },
+    { "Michael Müller", "d3d11/tests: Add some basic 1d texture tests in test_texture.", 1 },
+    { "Michael Müller", "d3d11/tests: Add some basic depth tests.", 1 },
+    { "Michael Müller", "d3d11/tests: Add support for 1d textures in check_rtv_desc_.", 1 },
+    { "Michael Müller", "d3d11/tests: Add support for 1d textures in check_srv_desc_.", 1 },
+    { "Michael Müller", "d3d11/tests: Add test for creating 1d textures.", 1 },
+    { "Michael Müller", "d3d11/tests: Don't use draw_quad in test_cb_relative_addressing.", 1 },
+    { "Michael Müller", "d3d11/tests: Prepare test_texture for 1d textures.", 1 },
+    { "Michael Müller", "d3d11/tests: Prepare test_texture for non 2d textures.", 1 },
+    { "Michael Müller", "d3d11/tests: Test 1d texture interfaces.", 1 },
+    { "Michael Müller", "d3d11/tests: Test the creation of 1d render buffers in test_create_rendertarget_view.", 1 },
+    { "Michael Müller", "d3d11/tests: Test the creation of 1d shader resource views in test_create_shader_resource_view.", 1 },
     { "Michael Müller", "d3dx9_36: Return dummy skininfo interface in D3DXLoadSkinMeshFromXof when skin information is unavailable.", 1 },
-    { "Michael Müller", "ddraw/tests: Add more tests for IDirect3DTexture2::Load.", 1 },
-    { "Michael Müller", "ddraw/tests: Add more tests for IDirectDraw7::EnumSurfaces.", 1 },
+    { "Michael Müller", "d3dx9_36/tests: Add initial tests for dummy skininfo interface.", 1 },
     { "Michael Müller", "ddraw: Accept d3d1 and d3d2 versions of D3DFINDDEVICERESULT in IDirect3D_FindDevice.", 1 },
     { "Michael Müller", "ddraw: Allow size and format conversions in IDirect3DTexture2::Load.", 1 },
     { "Michael Müller", "ddraw: Create rendering targets in video memory if possible.", 1 },
@@ -1143,6 +1141,8 @@
     { "Michael Müller", "ddraw: Remove const from ddraw1_vtbl and ddraw_surface1_vtbl.", 1 },
     { "Michael Müller", "ddraw: Set ddsOldCaps correctly in ddraw7_GetCaps.", 1 },
     { "Michael Müller", "ddraw: Set dwZBufferBitDepth in ddraw7_GetCaps.", 1 },
+    { "Michael Müller", "ddraw/tests: Add more tests for IDirect3DTexture2::Load.", 1 },
+    { "Michael Müller", "ddraw/tests: Add more tests for IDirectDraw7::EnumSurfaces.", 1 },
     { "Michael Müller", "devenum: Populate AudioCompressorCategory.", 1 },
     { "Michael Müller", "dwmapi: Add stubs for DwmSetIconicLivePreviewBitmap and DwmSetIconicThumbnail.", 1 },
     { "Michael Müller", "dxdiagn: Add several more fields for DisplayDevices.", 1 },
@@ -1152,7 +1152,6 @@
     { "Michael Müller", "dxgi: Improve stubs for MakeWindowAssociation and GetWindowAssociation.", 1 },
     { "Michael Müller", "dxgkrnl.sys: Add stub driver.", 1 },
     { "Michael Müller", "dxgmms1.sys: Add stub driver.", 1 },
-    { "Michael Müller", "dxva2/tests: Add tests for dxva2 decoder.", 1 },
     { "Michael Müller", "dxva2: Add DRM mode for vaapi.", 1 },
     { "Michael Müller", "dxva2: Always destroy buffers when calling vaRenderPicture.", 1 },
     { "Michael Müller", "dxva2: Fill h264 luma and chroma weights / offsets with default values in case they are not specified.", 1 },
@@ -1161,6 +1160,7 @@
     { "Michael Müller", "dxva2: Implement stubbed interfaces for IDirectXVideo{Acceleration,Decoder,Processor}Service.", 1 },
     { "Michael Müller", "dxva2: Initial implementation of MPEG2 decoder using vaapi backend.", 1 },
     { "Michael Müller", "dxva2: Only declare debug channels when they are actually used.", 1 },
+    { "Michael Müller", "dxva2/tests: Add tests for dxva2 decoder.", 1 },
     { "Michael Müller", "explorer: Create CurrentControlSet\\Control\\Video registry key as non-volatile.", 1 },
     { "Michael Müller", "ext-ms-win-appmodel-usercontext-l1-1-0: Add dll and add stub for UserContextExtInitialize.", 1 },
     { "Michael Müller", "ext-ms-win-ntuser-mouse-l1-1-0: Add dll.", 1 },
@@ -1181,17 +1181,15 @@
     { "Michael Müller", "imagehlp: Fix checksum calculation for odd sizes.", 1 },
     { "Michael Müller", "imagehlp: Implement ImageLoad and cleanup ImageUnload.", 1 },
     { "Michael Müller", "imm32: Add stub for ImmDisableLegacyIME.", 1 },
-    { "Michael Müller", "include/objidl.idl: Add IApartmentShutdown interface.", 1 },
-    { "Michael Müller", "include/roapi.h: Add further typedefs.", 1 },
-    { "Michael Müller", "include: Add IApplicationActivationManager interface declaration.", 1 },
     { "Michael Müller", "include: Add activation.idl with IActivationFactory interface.", 1 },
     { "Michael Müller", "include: Add dxva.h header file.", 1 },
+    { "Michael Müller", "include: Add IApplicationActivationManager interface declaration.", 1 },
     { "Michael Müller", "include: Add more constants to SYSTEM_INFORMATION_CLASS.", 1 },
     { "Michael Müller", "include: Add run level information enum and structure to winnt.h.", 1 },
+    { "Michael Müller", "include/objidl.idl: Add IApartmentShutdown interface.", 1 },
+    { "Michael Müller", "include/roapi.h: Add further typedefs.", 1 },
     { "Michael Müller", "include: Update LDR_MODULE to more recent windows versions.", 1 },
     { "Michael Müller", "inseng: Implement CIF reader and download functions.", 1 },
-    { "Michael Müller", "kernel32/tests: Add basic tests for fake dlls.", 1 },
-    { "Michael Müller", "kernel32/tests: Add tests for FindFirstFileA with invalid characters.", 1 },
     { "Michael Müller", "kernel32: Add stub for SetThreadIdealProcessorEx.", 1 },
     { "Michael Müller", "kernel32: Add support for progress callback in CopyFileEx.", 1 },
     { "Michael Müller", "kernel32: Add support for reading scsi devices from sysfs.", 1 },
@@ -1199,6 +1197,8 @@
     { "Michael Müller", "kernel32: Implement some processor group functions.", 1 },
     { "Michael Müller", "kernel32: Make K32GetPerformanceInfo faster.", 1 },
     { "Michael Müller", "kernel32: Strip invalid characters from mask in FindFirstFileExW.", 1 },
+    { "Michael Müller", "kernel32/tests: Add basic tests for fake dlls.", 1 },
+    { "Michael Müller", "kernel32/tests: Add tests for FindFirstFileA with invalid characters.", 1 },
     { "Michael Müller", "kernelbase: Add dll and add stub for QuirkIsEnabled.", 1 },
     { "Michael Müller", "krnl386.exe16: Do not reassign default handles after they got closed.", 1 },
     { "Michael Müller", "krnl386.exe16: Emulate GDT and LDT access.", 1 },
@@ -1213,9 +1213,9 @@
     { "Michael Müller", "mountmgr.sys: Write usable device paths into HKLM\\SYSTEM\\MountedDevices.", 1 },
     { "Michael Müller", "mpr: Return correct error code for non network paths and REMOTE_NAME_INFO_LEVEL in WNetGetUniversalName.", 1 },
     { "Michael Müller", "mscoree: Implement semi-stub for _CorValidateImage.", 1 },
-    { "Michael Müller", "msi/tests: Add custom action test framework and check MsiGetDatabaseState return value.", 1 },
     { "Michael Müller", "msi: Always return MSIDBSTATE_ERROR when MsiGetDatabaseState is called from a custom action.", 1 },
     { "Michael Müller", "msi: Create dummy thread to initialize COM for custom actions.", 1 },
+    { "Michael Müller", "msi/tests: Add custom action test framework and check MsiGetDatabaseState return value.", 1 },
     { "Michael Müller", "msvcr120: Add stub for _SetWinRTOutOfMemoryExceptionCallback.", 1 },
     { "Michael Müller", "msvfw32: Add test for negative width/height values passed to ICGetDisplayFormat.", 1 },
     { "Michael Müller", "msvfw32: Set biSizeImage correctly in ICGetDisplayFormat.", 1 },
@@ -1223,7 +1223,6 @@
     { "Michael Müller", "msvfw32: Try different formarts in ICGetDisplayFormat.", 1 },
     { "Michael Müller", "msvidc32: Add support for converting 16 bit depth to 24 bit.", 1 },
     { "Michael Müller", "msvidc32: Fix calculation of stride and size.", 1 },
-    { "Michael Müller", "ntdll/tests: Add basic tests for RtlQueryPackageIdentity.", 1 },
     { "Michael Müller", "ntdll: Add dummy apiset to PEB.", 1 },
     { "Michael Müller", "ntdll: Add stub for ApiSetQueryApiSetPresence.", 1 },
     { "Michael Müller", "ntdll: Add stub for NtContinue.", 1 },
@@ -1240,43 +1239,43 @@
     { "Michael Müller", "ntdll: Fix error code when querying too large memory address.", 1 },
     { "Michael Müller", "ntdll: Fix holes in ELF mappings.", 2 },
     { "Michael Müller", "ntdll: Fix parameters for RtlIpv4StringToAddressExW stub.", 1 },
+    { "Michael Müller", "ntdll: Implement basic IO stats for SystemPerformanceInformation in NtQuerySystemInformation.", 1 },
+    { "Michael Müller", "ntdll: Implement get_redirect function.", 1 },
     { "Michael Müller", "ntdll: Implement HashLinks field in LDR module data.", 1 },
+    { "Michael Müller", "ntdll: Implement loader redirection scheme.", 1 },
     { "Michael Müller", "ntdll: Implement NtSuspendProcess and NtResumeProcess.", 1 },
     { "Michael Müller", "ntdll: Implement ObjectTypesInformation in NtQueryObject.", 1 },
+    { "Michael Müller", "ntdll: Implement opening files through nt device paths.", 1 },
     { "Michael Müller", "ntdll: Implement ProcessImageFileNameWin32 in NtQueryInformationProcess.", 1 },
     { "Michael Müller", "ntdll: Implement ProcessPriorityClass in NtQueryInformationProcess.", 1 },
+    { "Michael Müller", "ntdll: Implement querying for FileNameInformation of named pipes in NtQueryInformationFile.", 1 },
     { "Michael Müller", "ntdll: Implement RunlevelInformationInActivationContext in RtlQueryInformationActivationContext.", 1 },
     { "Michael Müller", "ntdll: Implement SystemExtendedHandleInformation in NtQuerySystemInformation.", 1 },
-    { "Michael Müller", "ntdll: Implement basic IO stats for SystemPerformanceInformation in NtQuerySystemInformation.", 1 },
-    { "Michael Müller", "ntdll: Implement get_redirect function.", 1 },
-    { "Michael Müller", "ntdll: Implement loader redirection scheme.", 1 },
-    { "Michael Müller", "ntdll: Implement opening files through nt device paths.", 1 },
-    { "Michael Müller", "ntdll: Implement querying for FileNameInformation of named pipes in NtQueryInformationFile.", 1 },
     { "Michael Müller", "ntdll: Improve speed of LdrGetDllHandle when searching for the basename of modules that are not loaded.", 1 },
     { "Michael Müller", "ntdll: Load CLI/.NET images in the same way as Windows XP and above.", 1 },
     { "Michael Müller", "ntdll: Mimic object type behavior for different windows versions.", 1 },
-    { "Michael Müller", "ntdll: Move NtProtectVirtualMemory and NtCreateSection to separate pages on x86.", 2 },
     { "Michael Müller", "ntdll: Move code to determine module basename into separate function.", 1 },
     { "Michael Müller", "ntdll: Move logic to determine loadorder HKCU/app key into separate functions.", 1 },
     { "Michael Müller", "ntdll: Move logic to read loadorder registry values into separate function.", 1 },
+    { "Michael Müller", "ntdll: Move NtProtectVirtualMemory and NtCreateSection to separate pages on x86.", 2 },
     { "Michael Müller", "ntdll: Parse execution level information in manifest data.", 1 },
     { "Michael Müller", "ntdll: Properly handle PAGE_WRITECOPY protection.", 5 },
     { "Michael Müller", "ntdll: Report system information SystemPerformanceInformation info class.", 2 },
     { "Michael Müller", "ntdll: Return success for TokenSessionId in NtSetInformationToken.", 1 },
-    { "Michael Müller", "ntdll: Set TypeIndex for ObjectTypeInformation in NtQueryObject.", 1 },
     { "Michael Müller", "ntdll: Set correct thread creation time for SystemProcessInformation in NtQuerySystemInformation.", 1 },
     { "Michael Müller", "ntdll: Set object type for System(Extended)HandleInformation in NtQuerySystemInformation.", 1 },
     { "Michael Müller", "ntdll: Set process start time.", 1 },
+    { "Michael Müller", "ntdll: Set TypeIndex for ObjectTypeInformation in NtQueryObject.", 1 },
     { "Michael Müller", "ntdll: Setup a temporary signal handler during process startup to handle page faults.", 2 },
+    { "Michael Müller", "ntdll/tests: Add basic tests for RtlQueryPackageIdentity.", 1 },
     { "Michael Müller", "ntdll: Use HashLinks when searching for a dll using the basename.", 1 },
+    { "Michael Müller", "ntoskrnl.exe: Implement ExInitializeNPagedLookasideList.", 1 },
+    { "Michael Müller", "ntoskrnl.exe: Implement NtBuildNumber.", 1 },
     { "Michael Müller", "ntoskrnl.exe/tests: Add kernel compliant test functions.", 1 },
     { "Michael Müller", "ntoskrnl.exe/tests: Add tests for ExInitializeNPagedLookasideList.", 1 },
     { "Michael Müller", "ntoskrnl.exe/tests: Add tests for NtBuildNumber.", 1 },
     { "Michael Müller", "ntoskrnl.exe/tests: Check ldr module order and some common kernel drivers.", 1 },
-    { "Michael Müller", "ntoskrnl.exe: Implement ExInitializeNPagedLookasideList.", 1 },
-    { "Michael Müller", "ntoskrnl.exe: Implement NtBuildNumber.", 1 },
     { "Michael Müller", "ntoskrnl: Implement ExInterlockedPopEntrySList.", 1 },
-    { "Michael Müller", "nvapi/tests: Use structure to list imports.", 1 },
     { "Michael Müller", "nvapi: Add NvAPI_GetPhysicalGPUsFromLogicalGPU.", 1 },
     { "Michael Müller", "nvapi: Add stub for EnumNvidiaDisplayHandle.", 1 },
     { "Michael Müller", "nvapi: Add stub for NvAPI_D3D9_RegisterResource.", 1 },
@@ -1284,8 +1283,8 @@
     { "Michael Müller", "nvapi: Add stub for NvAPI_D3D_GetObjectHandleForResource.", 1 },
     { "Michael Müller", "nvapi: Add stub for NvAPI_DISP_GetGDIPrimaryDisplayId.", 1 },
     { "Michael Müller", "nvapi: Add stub for NvAPI_EnumPhysicalGPUs.", 1 },
-    { "Michael Müller", "nvapi: Add stub for NvAPI_GPU_GetGpuCoreCount.", 1 },
     { "Michael Müller", "nvapi: Add stub for NvAPI_GetLogicalGPUFromDisplay.", 1 },
+    { "Michael Müller", "nvapi: Add stub for NvAPI_GPU_GetGpuCoreCount.", 1 },
     { "Michael Müller", "nvapi: Add stub for NvAPI_SYS_GetDriverAndBranchVersion.", 1 },
     { "Michael Müller", "nvapi: Add stub for NvAPI_Unload.", 1 },
     { "Michael Müller", "nvapi: Add stubs for NvAPI_EnumLogicalGPUs and undocumented equivalent.", 1 },
@@ -1296,6 +1295,7 @@
     { "Michael Müller", "nvapi: Implement NvAPI_GPU_Get{Physical,Virtual}FrameBufferSize.", 1 },
     { "Michael Müller", "nvapi: Improve NvAPI_D3D_GetCurrentSLIState.", 1 },
     { "Michael Müller", "nvapi: Print fixme message for NvAPI_D3D9_StretchRectEx.", 1 },
+    { "Michael Müller", "nvapi/tests: Use structure to list imports.", 1 },
     { "Michael Müller", "nvcuda: Emulate two d3d9 initialization functions.", 1 },
     { "Michael Müller", "nvcuda: First implementation.", 2 },
     { "Michael Müller", "nvcuda: Properly wrap undocumented 'ContextStorage' interface and add tests.", 1 },
@@ -1321,20 +1321,20 @@
     { "Michael Müller", "server: Register types during startup.", 1 },
     { "Michael Müller", "server: Rename ObjectType to Type.", 1 },
     { "Michael Müller", "server: Reset debug registers when creating threads.", 1 },
-    { "Michael Müller", "setupapi/tests: Add test for IDF_CHECKFIRST and SetupPromptForDiskA/W.", 1 },
     { "Michael Müller", "setupapi: Add spec file stub entry for SetupDiInstallDeviceInterfaces and SetupDiRegisterCoDeviceInstallers.", 1 },
     { "Michael Müller", "setupapi: Add support for IDF_CHECKFIRST flag in SetupPromptForDiskW.", 1 },
     { "Michael Müller", "setupapi: Check handle type for HSPFILEQ handles.", 1 },
     { "Michael Müller", "setupapi: Create registry keys for display devices and display drivers.", 1 },
     { "Michael Müller", "setupapi: Handle the case that a full driver path is passed to SetupDiGetClassDevs.", 1 },
     { "Michael Müller", "setupapi: Ignore deletion of added files in SetupAddToDiskSpaceList.", 1 },
-    { "Michael Müller", "setupapi: Implement SP_COPY_IN_USE_NEEDS_REBOOT.", 1 },
     { "Michael Müller", "setupapi: Implement SetupAddInstallSectionToDiskSpaceList.", 1 },
+    { "Michael Müller", "setupapi: ImplementSetupAddSectionToDiskSpaceList.", 1 },
     { "Michael Müller", "setupapi: Implement SetupAddToDiskSpaceList.", 1 },
     { "Michael Müller", "setupapi: Implement SetupQueryDrivesInDiskSpaceList.", 1 },
-    { "Michael Müller", "setupapi: ImplementSetupAddSectionToDiskSpaceList.", 1 },
+    { "Michael Müller", "setupapi: Implement SP_COPY_IN_USE_NEEDS_REBOOT.", 1 },
     { "Michael Müller", "setupapi: Rewrite DiskSpaceList logic using lists.", 1 },
     { "Michael Müller", "setupapi: SetupDiGetDeviceInterfaceDetail should fill out DeviceInfoData even if the buffer for DeviceInterfaceData is too small.", 1 },
+    { "Michael Müller", "setupapi/tests: Add test for IDF_CHECKFIRST and SetupPromptForDiskA/W.", 1 },
     { "Michael Müller", "sfc_os: Set an error code in SfcGetNextProtectedFile stub.", 1 },
     { "Michael Müller", "shell32: Add general tab in file property dialog.", 1 },
     { "Michael Müller", "shell32: Add parameter to ISFHelper::DeleteItems to allow deleting files without confirmation.", 1 },
@@ -1346,16 +1346,16 @@
     { "Michael Müller", "shell32: Correct indentation in shfileop.c.", 1 },
     { "Michael Müller", "shell32: Do not use unixfs for devices without mountpoint.", 1 },
     { "Michael Müller", "shell32: Fix copying of files when using a context menu.", 1 },
-    { "Michael Müller", "shell32: Implement NewMenu with new folder item.", 1 },
     { "Michael Müller", "shell32: Implement file operation progress dialog.", 1 },
     { "Michael Müller", "shell32: Implement insert/paste for item context menus.", 1 },
+    { "Michael Müller", "shell32: Implement NewMenu with new folder item.", 1 },
     { "Michael Müller", "shell32: Improve FolderItemsImpl_get_Count stub.", 1 },
     { "Michael Müller", "shell32: Pass FILE_INFORMATION into SHNotify* functions.", 1 },
     { "Michael Müller", "shell32: Recognize cut/copy/paste string verbs in item menu context menu.", 1 },
     { "Michael Müller", "shell32: Remove source files when using cut in the context menu.", 1 },
+    { "Michael Müller", "shell32: Set return value correctly in DoPaste.", 1 },
     { "Michael Müller", "shell32: Set SFGAO_HASSUBFOLDER correctly for normal shellfolders.", 1 },
     { "Michael Müller", "shell32: Set SFGAO_HASSUBFOLDER correctly for unixfs.", 1 },
-    { "Michael Müller", "shell32: Set return value correctly in DoPaste.", 1 },
     { "Michael Müller", "shell32: Show animation during SHFileOperation.", 1 },
     { "Michael Müller", "shell32: Use manual redirection for RunDLL_CallEntry16.", 1 },
     { "Michael Müller", "taskmgr: Use different units depending on memory usage.", 1 },
@@ -1387,9 +1387,6 @@
     { "Michael Müller", "wbemprox: Provide DeviceID, Location and PortName for printers.", 1 },
     { "Michael Müller", "wevtapi: Add stub for EvtNext.", 1 },
     { "Michael Müller", "win32k.sys: Add stub driver.", 1 },
-    { "Michael Müller", "wine.inf.in: Add invalid dummy certificate to CA certificate store.", 1 },
-    { "Michael Müller", "wine.inf: Add 'New' context menu handler entry for directories.", 1 },
-    { "Michael Müller", "wine.inf: Add WMP 12 as installed windows feature.", 1 },
     { "Michael Müller", "wineboot: Add some generic hardware in HKEY_DYN_DATA\\Config Manager\\Enum.", 1 },
     { "Michael Müller", "wineboot: Initialize proxy settings registry key.", 1 },
     { "Michael Müller", "winebuild: Add stub functions in fake dlls.", 1 },
@@ -1403,19 +1400,19 @@
     { "Michael Müller", "winecfg: Show unmounted devices and allow changing the device value.", 1 },
     { "Michael Müller", "wined3d: Add 1d texture resource type.", 1 },
     { "Michael Müller", "wined3d: Add DXT1 to B4G4R4A4, DXT1 to B5G5R5A1 and DXT3 to B4G4R4A4 conversion.", 1 },
-    { "Michael Müller", "wined3d: Add WINED3DFMT_R8G8B8A8_SNORM to WINED3DFMT_R8G8B8A8_TYPELESS group.", 1 },
     { "Michael Müller", "wined3d: Add hack for WINED3DFMT_R24_UNORM_X8_TYPELESS.", 1 },
     { "Michael Müller", "wined3d: Add is_power_of_two helper function.", 1 },
     { "Michael Müller", "wined3d: Add stubs for QUERY_TYPE_SO_STATISTICS and QUERY_TYPE_SO_OVERFLOW.", 1 },
     { "Michael Müller", "wined3d: Add support for 1d textures in context_attach_gl_texture_fbo.", 1 },
     { "Michael Müller", "wined3d: Add support for DXTn software decoding through libtxc_dxtn.", 3 },
+    { "Michael Müller", "wined3d: Add WINED3DFMT_R8G8B8A8_SNORM to WINED3DFMT_R8G8B8A8_TYPELESS group.", 1 },
     { "Michael Müller", "wined3d: Add wined3d_resource_map_info function.", 1 },
     { "Michael Müller", "wined3d: Allow changing strict drawing through an exported function.", 1 },
     { "Michael Müller", "wined3d: Allow creation of 1d shader views.", 1 },
     { "Michael Müller", "wined3d: Check for 1d textures in wined3d_texture_update_desc.", 1 },
     { "Michael Müller", "wined3d: Check if 1d teture is still in use before releasing.", 1 },
-    { "Michael Müller", "wined3d: Create dummy 1d textures and surfaces.", 1 },
     { "Michael Müller", "wined3d: Create dummy 1d textures.", 1 },
+    { "Michael Müller", "wined3d: Create dummy 1d textures and surfaces.", 1 },
     { "Michael Müller", "wined3d: Discard buffer during upload when replacing complete content.", 1 },
     { "Michael Müller", "wined3d: Do not pin large buffers.", 1 },
     { "Michael Müller", "wined3d: Emulate sample_c_lz using textureGradOffset for sampler2DArrayShadow.", 1 },
@@ -1434,15 +1431,15 @@
     { "Michael Müller", "wined3d: Use OpenGL core context for D3D10/11 when necessary.", 1 },
     { "Michael Müller", "wined3d: Use real values for memory accounting on NVIDIA cards.", 1 },
     { "Michael Müller", "wined3d: Use wined3d_cs_emit_copy_sub_resource also for wined3d_device_copy_resource.", 1 },
+    { "Michael Müller", "wine.inf: Add 'New' context menu handler entry for directories.", 1 },
+    { "Michael Müller", "wine.inf: Add WMP 12 as installed windows feature.", 1 },
+    { "Michael Müller", "wine.inf.in: Add invalid dummy certificate to CA certificate store.", 1 },
     { "Michael Müller", "winemp3.acm: Check input format in MPEG3_StreamOpen.", 1 },
     { "Michael Müller", "winex11.drv: Allow changing the opengl pixel format on the desktop window.", 1 },
     { "Michael Müller", "winex11.drv: Allow to select default display frequency in registry key.", 1 },
     { "Michael Müller", "winex11.drv: Indicate direct rendering through OpenGL extension.", 1 },
     { "Michael Müller", "winex11.drv: Only warn about used contexts in wglShareLists.", 1 },
     { "Michael Müller", "winex11: Prevent window managers from grouping all wine programs together.", 1 },
-    { "Michael Müller", "wininet/tests: Add more tests for cookies.", 1 },
-    { "Michael Müller", "wininet/tests: Check cookie behaviour when overriding host.", 1 },
-    { "Michael Müller", "wininet/tests: Test auth credential reusage with host override.", 1 },
     { "Michael Müller", "wininet: Add support for INTERNET_OPTION_SETTINGS_CHANGED in InternetSetOption.", 1 },
     { "Michael Müller", "wininet: Allow INTERNET_OPTION_SETTINGS_CHANGED on connections.", 1 },
     { "Michael Müller", "wininet: Allow to set INTERNET_OPTION_HTTP_DECODING on sessions and connections.", 1 },
@@ -1450,68 +1447,66 @@
     { "Michael Müller", "wininet: Resize buffer when call to InternetCanonicalizeUrlW fails in InternetCrackUrlW.", 1 },
     { "Michael Müller", "wininet: Return failure when handling http redirect without hostname.", 1 },
     { "Michael Müller", "wininet: Strip filename if no path is set in cookie.", 1 },
+    { "Michael Müller", "wininet/tests: Add more tests for cookies.", 1 },
+    { "Michael Müller", "wininet/tests: Check cookie behaviour when overriding host.", 1 },
+    { "Michael Müller", "wininet/tests: Test auth credential reusage with host override.", 1 },
     { "Michael Müller", "winmm: Delay import ole32 msacm32 to workaround bug when loading multiple winmm versions.", 1 },
     { "Michael Müller", "winmm: Do not crash in Win 9X mode when an invalid device ptr is passed to MCI_OPEN.", 1 },
     { "Michael Müller", "wuauserv: Add dummy service.", 1 },
     { "Michael Müller", "wusa: Ignore systemProtection subkey of registry key.", 1 },
-    { "Michael Müller", "wusa: Implement WOW64 support.", 1 },
     { "Michael Müller", "wusa: Implement basic installation logic.", 1 },
+    { "Michael Müller", "wusa: Implement WOW64 support.", 1 },
     { "Michael Müller", "wusa: Print warning when encountering msdelta compressed files.", 1 },
     { "Michael Müller", "wusa: Treat empty update list as error.", 1 },
     { "Michael Müller", "xinput9_1_0: Build independent xinput9_1_0.dll instead of using forwards.", 1 },
-    { "Qian Hong", "advapi32/tests: Test prefix and use of TokenPrimaryGroup Sid.", 1 },
     { "Qian Hong", "advapi32: Fallback to Sid string when LookupAccountSid fails.", 1 },
     { "Qian Hong", "advapi32: Fix name and use of DOMAIN_GROUP_RID_USERS.", 1 },
     { "Qian Hong", "advapi32: Initialize buffer length to zero in LsaLookupSids to prevent crash.", 2 },
     { "Qian Hong", "advapi32: Prepend a hidden LSA_TRUST_INFORMATION in LsaLookupNames2 to avoid crash when Domains[-1] incorrectly accessed by application.", 2 },
     { "Qian Hong", "advapi32: Prepend a hidden LSA_TRUST_INFORMATION in LsaLookupSids to avoid crash when Domains[-1] incorrectly accessed by application.", 2 },
+    { "Qian Hong", "advapi32/tests: Test prefix and use of TokenPrimaryGroup Sid.", 1 },
     { "Qian Hong", "kernel32: Fallback to default comspec when %COMSPEC% is not set.", 1 },
     { "Qian Hong", "kernel32: Init TimezoneInformation registry.", 1 },
-    { "Qian Hong", "ntdll/tests: Added tests for open behaviour on readonly files.", 1 },
-    { "Qian Hong", "ntdll/tests: Added tests to set disposition on file which is mapped to memory.", 1 },
     { "Qian Hong", "ntdll: Add fake data implementation for ProcessQuotaLimits class.", 1 },
     { "Qian Hong", "ntdll: Improve invalid paramater handling in NtAccessCheck.", 1 },
     { "Qian Hong", "ntdll: Initialize mod_name to zero.", 1 },
     { "Qian Hong", "ntdll: Set EOF on file which has a memory mapping should fail.", 1 },
+    { "Qian Hong", "ntdll/tests: Added tests for open behaviour on readonly files.", 1 },
+    { "Qian Hong", "ntdll/tests: Added tests to set disposition on file which is mapped to memory.", 1 },
     { "Qian Hong", "server: Create primary group using DOMAIN_GROUP_RID_USERS.", 1 },
     { "Qian Hong", "server: Do not allow to set disposition on file which has a file mapping.", 1 },
     { "Qian Hong", "server: Map EXDEV to STATUS_NOT_SAME_DEVICE.", 1 },
     { "Samuel Kim", "comctl32: Fix buttons becoming unthemed when pressed/released.", 1 },
-    { "Sebastian Lackner", "Revert \"dsound: Simplify error handling when creating a sound buffer.\".", 1 },
-    { "Sebastian Lackner", "Revert \"dsound: Use a better name for IDirectSoundBufferImpl_Create().\".", 1 },
-    { "Sebastian Lackner", "Revert \"opengl32: Return a NULL pointer for functions requiring unsupported or disabled extensions.\".", 1 },
-    { "Sebastian Lackner", "Revert \"wined3d: Implement wined3d_buffer_upload_data() on top of wined3d_buffer_upload_ranges().\".", 1 },
-    { "Sebastian Lackner", "Revert \"winemp3.acm: Disallow operations encoding to MPEG.\".", 1 },
     { "Sebastian Lackner", "advapi32/tests: Add ACL inheritance tests for creating subdirectories with NtCreateFile.", 1 },
     { "Sebastian Lackner", "advapi32/tests: Add basic tests for BuildSecurityDescriptor.", 1 },
     { "Sebastian Lackner", "advapi32/tests: Add tests for ACL inheritance in CreateDirectoryA.", 1 },
     { "Sebastian Lackner", "advapi: Trigger write watches before passing userdata pointer to read syscall.", 1 },
     { "Sebastian Lackner", "amstream: Avoid implicit cast of interface pointer.", 1 },
     { "Sebastian Lackner", "appwiz.cpl: Copy addons to cache instead of moving.", 1 },
-    { "Sebastian Lackner", "bcrypt/tests: Add test for bugs in BCryptGetProperty.", 1 },
-    { "Sebastian Lackner", "bcrypt/tests: Add tests for BCryptDuplicateKey.", 1 },
-    { "Sebastian Lackner", "bcrypt/tests: Add tests for auth data in AES GCM mode.", 1 },
     { "Sebastian Lackner", "bcrypt: Avoid crash in tests when compiling without gnutls support.", 1 },
     { "Sebastian Lackner", "bcrypt: Fix string comparison in set_alg_property.", 1 },
     { "Sebastian Lackner", "bcrypt: Implement support for ECB chain mode.", 1 },
     { "Sebastian Lackner", "bcrypt: Pass object to get_{alg,hash}_property instead of alg_id.", 1 },
+    { "Sebastian Lackner", "bcrypt/tests: Add test for bugs in BCryptGetProperty.", 1 },
+    { "Sebastian Lackner", "bcrypt/tests: Add tests for auth data in AES GCM mode.", 1 },
+    { "Sebastian Lackner", "bcrypt/tests: Add tests for BCryptDuplicateKey.", 1 },
     { "Sebastian Lackner", "configure: Also add the absolute RPATH when linking against libwine.", 1 },
     { "Sebastian Lackner", "d2d1: Avoid implicit cast of interface pointer.", 1 },
     { "Sebastian Lackner", "d3d10_1: Add missing forwards to d3d10.", 1 },
-    { "Sebastian Lackner", "d3d11/tests: Avoid test failures.", 1 },
     { "Sebastian Lackner", "d3d11: Avoid implicit cast of interface pointer.", 1 },
+    { "Sebastian Lackner", "d3d11/tests: Avoid test failures.", 1 },
     { "Sebastian Lackner", "d3d8: Avoid implicit cast of interface pointer.", 1 },
     { "Sebastian Lackner", "d3d8: Improve ValidatePixelShader stub.", 1 },
     { "Sebastian Lackner", "d3d8: Improve ValidateVertexShader stub.", 1 },
-    { "Sebastian Lackner", "d3d9/tests: Avoid test failures on specific Nvidia graphic cards.", 1 },
     { "Sebastian Lackner", "d3d9: Avoid implicit cast of interface pointer.", 1 },
-    { "Sebastian Lackner", "d3dx9_*: Adjust ID3DXEffect interface based on DLL version.", 1 },
+    { "Sebastian Lackner", "d3d9/tests: Avoid test failures on specific Nvidia graphic cards.", 1 },
+    { "Sebastian Lackner", "d3dx9_36: Improve stub for ID3DXEffectImpl_CloneEffect.", 1 },
     { "Sebastian Lackner", "d3dx9_36/tests: Add initial tests for D3DXDisassembleShader.", 1 },
     { "Sebastian Lackner", "d3dx9_36/tests: Fix some test failures.", 1 },
-    { "Sebastian Lackner", "d3dx9_36: Improve stub for ID3DXEffectImpl_CloneEffect.", 1 },
+    { "Sebastian Lackner", "d3dx9_*: Adjust ID3DXEffect interface based on DLL version.", 1 },
     { "Sebastian Lackner", "dbghelp: Always check for debug symbols in BINDIR.", 1 },
-    { "Sebastian Lackner", "ddraw/tests: Fix function name in multiple ok() messages.", 1 },
     { "Sebastian Lackner", "ddraw: Avoid implicit cast of interface pointer.", 1 },
+    { "Sebastian Lackner", "ddraw/tests: Fix function name in multiple ok() messages.", 1 },
     { "Sebastian Lackner", "dinput: Do not wait for hook thread startup in IDirectInput8::Initialize.", 1 },
     { "Sebastian Lackner", "dmloader/tests: Fix test failures.", 1 },
     { "Sebastian Lackner", "dsound: Allow disabling of EAX support in the registry.", 1 },
@@ -1522,14 +1517,12 @@
     { "Sebastian Lackner", "dxva2: Implement semi-stub for Direct3DDeviceManager9 interface.", 1 },
     { "Sebastian Lackner", "fonts: Add Liberation Mono as an Courier New replacement.", 1 },
     { "Sebastian Lackner", "fonts: Add Liberation Serif as an Times New Roman replacement.", 1 },
-    { "Sebastian Lackner", "fusion/tests: Avoid compiler warnings with GCC 7.", 1 },
     { "Sebastian Lackner", "fusion: Fix length parameter for ZeroMemory.", 1 },
+    { "Sebastian Lackner", "fusion/tests: Avoid compiler warnings with GCC 7.", 1 },
     { "Sebastian Lackner", "gdi32: Perform lazy initialization of fonts to improve startup performance.", 1 },
     { "Sebastian Lackner", "include: Add cuda.h.", 1 },
     { "Sebastian Lackner", "include: Check element type in CONTAINING_RECORD and similar macros.", 1 },
     { "Sebastian Lackner", "iphlpapi: Fallback to system ping when ICMP permissions are not present.", 1 },
-    { "Sebastian Lackner", "kernel32/tests: Add additional tests for condition mask of VerifyVersionInfoA.", 1 },
-    { "Sebastian Lackner", "kernel32/tests: Avoid compiler warnings with GCC 7.", 1 },
     { "Sebastian Lackner", "kernel32: Add detection for position independent executables.", 1 },
     { "Sebastian Lackner", "kernel32: Add winediag message to show warning, that this isn't vanilla wine.", 1 },
     { "Sebastian Lackner", "kernel32: Allow non-nullterminated string as working directory in create_startup_info.", 1 },
@@ -1537,14 +1530,14 @@
     { "Sebastian Lackner", "kernel32: Avoid compiler warnings with GCC 7.", 1 },
     { "Sebastian Lackner", "kernel32: Fill stack with meaningful values in call_process_entry mis-align workaround.", 1 },
     { "Sebastian Lackner", "kernel32: Implement passing security descriptors from CreateProcess to the wineserver.", 2 },
+    { "Sebastian Lackner", "kernel32/tests: Add additional tests for condition mask of VerifyVersionInfoA.", 1 },
+    { "Sebastian Lackner", "kernel32/tests: Avoid compiler warnings with GCC 7.", 1 },
     { "Sebastian Lackner", "krnl386.exe16: Do not abuse WOW32Reserved field for 16-bit stack address.", 1 },
     { "Sebastian Lackner", "loader: Add commandline option --patches to show the patch list.", 1 },
     { "Sebastian Lackner", "loader: Implement preloader for Mac OS.", 1 },
     { "Sebastian Lackner", "makedep: Add support for PARENTSPEC Makefile variable.", 1 },
     { "Sebastian Lackner", "msvcrt: Calculate sinh/cosh/exp/pow with higher precision.", 2 },
     { "Sebastian Lackner", "msxml3: Avoid implicit cast of interface pointer.", 1 },
-    { "Sebastian Lackner", "ntdll/tests: Add more tests for FileIoCompletionNotificationInformation.", 1 },
-    { "Sebastian Lackner", "ntdll/tests: Add test to ensure section name is full path.", 1 },
     { "Sebastian Lackner", "ntdll: Add semi-stub for FileFsVolumeInformation information class.", 1 },
     { "Sebastian Lackner", "ntdll: Add special handling for \\SystemRoot to satisfy MSYS2 case-insensitive system check.", 1 },
     { "Sebastian Lackner", "ntdll: Add support for hiding wine version information from applications.", 1 },
@@ -1561,8 +1554,8 @@
     { "Sebastian Lackner", "ntdll: Fix condition mask handling in RtlVerifyVersionInfo.", 1 },
     { "Sebastian Lackner", "ntdll: Fix race-condition when threads are killed during shutdown.", 1 },
     { "Sebastian Lackner", "ntdll: Fix return value for missing ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION key.", 1 },
-    { "Sebastian Lackner", "ntdll: Implement FileIoCompletionNotificationInformation info class.", 2 },
     { "Sebastian Lackner", "ntdll: Implement _alldvrm/_aulldvrm and add tests.", 1 },
+    { "Sebastian Lackner", "ntdll: Implement FileIoCompletionNotificationInformation info class.", 2 },
     { "Sebastian Lackner", "ntdll: Implement virtual_map_shared_memory.", 1 },
     { "Sebastian Lackner", "ntdll: Improve stub of NtQueryEaFile.", 1 },
     { "Sebastian Lackner", "ntdll: Move code to update user shared data into a separate function.", 1 },
@@ -1571,13 +1564,15 @@
     { "Sebastian Lackner", "ntdll: Process APC calls before starting process.", 1 },
     { "Sebastian Lackner", "ntdll: Remove memory limitation to 32GB on 64-bit by growing heap dynamically.", 2 },
     { "Sebastian Lackner", "ntdll: Resolve drive symlinks before returning section name.", 1 },
-    { "Sebastian Lackner", "ntdll: Return STATUS_INVALID_DEVICE_REQUEST when trying to call NtReadFile on directory.", 1 },
     { "Sebastian Lackner", "ntdll: Return buffer filled with random values from SystemInterruptInformation.", 1 },
     { "Sebastian Lackner", "ntdll: Return correct values in GetThreadTimes() for all threads.", 1 },
     { "Sebastian Lackner", "ntdll: Return fake device type when systemroot is located on virtual disk.", 1 },
+    { "Sebastian Lackner", "ntdll: Return STATUS_INVALID_DEVICE_REQUEST when trying to call NtReadFile on directory.", 1 },
     { "Sebastian Lackner", "ntdll: Reuse old async fileio structures if possible.", 1 },
     { "Sebastian Lackner", "ntdll: Set proper ExceptionInformation[0] for x86_64 exceptions.", 1 },
     { "Sebastian Lackner", "ntdll: Skip get_dll_info wineserver call if address does not have VPROT_IMAGE permissions.", 1 },
+    { "Sebastian Lackner", "ntdll/tests: Add more tests for FileIoCompletionNotificationInformation.", 1 },
+    { "Sebastian Lackner", "ntdll/tests: Add test to ensure section name is full path.", 1 },
     { "Sebastian Lackner", "ntdll: Throw exception if invalid handle is passed to NtClose and debugger enabled.", 1 },
     { "Sebastian Lackner", "ntdll: Trigger stack overflow exception earlier on x86_64.", 1 },
     { "Sebastian Lackner", "ntdll: Trigger write watches before passing userdata pointer to wait_reply.", 1 },
@@ -1592,17 +1587,22 @@
     { "Sebastian Lackner", "ole32: Improve thread-safety of HGLOBALStreamImpl_Read.", 1 },
     { "Sebastian Lackner", "ole32: Improve thread-safety of HGLOBALStreamImpl_Write.", 1 },
     { "Sebastian Lackner", "ole32: Set DebugInfo->Spare[0] for handle_wrapper lock.", 1 },
-    { "Sebastian Lackner", "oleaut32/tests: Add a test for TKIND_COCLASS in proxy/stub marshalling.", 1 },
     { "Sebastian Lackner", "oleaut32: Avoid implicit cast of interface pointer.", 1 },
     { "Sebastian Lackner", "oleaut32: Handle TKIND_COCLASS in proxy/stub marshalling.", 1 },
+    { "Sebastian Lackner", "oleaut32: Implement asm proxys for x86_64.", 1 },
     { "Sebastian Lackner", "oleaut32: Implement ITypeInfo_fnInvoke for TKIND_COCLASS in arguments.", 1 },
     { "Sebastian Lackner", "oleaut32: Implement SaveAsFile for PICTYPE_ENHMETAFILE.", 1 },
     { "Sebastian Lackner", "oleaut32: Implement TMStubImpl_Invoke on x86_64.", 1 },
-    { "Sebastian Lackner", "oleaut32: Implement asm proxys for x86_64.", 1 },
     { "Sebastian Lackner", "oleaut32: Initial preparation to make marshalling compatible with x86_64.", 1 },
     { "Sebastian Lackner", "oleaut32: Pass a HREFTYPE to get_iface_guid.", 1 },
+    { "Sebastian Lackner", "oleaut32/tests: Add a test for TKIND_COCLASS in proxy/stub marshalling.", 1 },
     { "Sebastian Lackner", "opengl32: Add wrappers for glDebugMessageCallback to handle calling convention differences.", 1 },
     { "Sebastian Lackner", "reg/tests: Don't call RegCloseKey on uninitialized memory.", 1 },
+    { "Sebastian Lackner", "Revert \"dsound: Simplify error handling when creating a sound buffer.\".", 1 },
+    { "Sebastian Lackner", "Revert \"dsound: Use a better name for IDirectSoundBufferImpl_Create().\".", 1 },
+    { "Sebastian Lackner", "Revert \"opengl32: Return a NULL pointer for functions requiring unsupported or disabled extensions.\".", 1 },
+    { "Sebastian Lackner", "Revert \"wined3d: Implement wined3d_buffer_upload_data() on top of wined3d_buffer_upload_ranges().\".", 1 },
+    { "Sebastian Lackner", "Revert \"winemp3.acm: Disallow operations encoding to MPEG.\".", 1 },
     { "Sebastian Lackner", "riched20: Silence repeated FIXMEs triggered by Adobe Reader.", 1 },
     { "Sebastian Lackner", "rpcrt4: Avoid implicit cast of interface pointer.", 1 },
     { "Sebastian Lackner", "rsaenh/tests: Avoid compiler warnings with GCC 7.", 1 },
@@ -1615,9 +1615,9 @@
     { "Sebastian Lackner", "server: Fix handling of GetMessage after previous PeekMessage call.", 3 },
     { "Sebastian Lackner", "server: Growing files which are mapped to memory should still work.", 1 },
     { "Sebastian Lackner", "server: Implement locking and synchronization of keystate buffer.", 3 },
-    { "Sebastian Lackner", "server: Improve STATUS_CANNOT_DELETE checks for directory case.", 1 },
     { "Sebastian Lackner", "server: Improve handling of cursor position clipping for empty rectangle.", 2 },
     { "Sebastian Lackner", "server: Improve mapping of DACL to file permissions.", 1 },
+    { "Sebastian Lackner", "server: Improve STATUS_CANNOT_DELETE checks for directory case.", 1 },
     { "Sebastian Lackner", "server: Introduce a helper function to update the thread_input key state.", 1 },
     { "Sebastian Lackner", "server: Introduce a new alloc_handle object callback.", 2 },
     { "Sebastian Lackner", "server: Introduce refcounting for registry notifications.", 1 },
@@ -1630,24 +1630,21 @@
     { "Sebastian Lackner", "server: Track desktop handle count more correctly.", 1 },
     { "Sebastian Lackner", "server: When combining root and name, make sure there is only one slash.", 2 },
     { "Sebastian Lackner", "server: When creating new directories temporarily give read-permissions until they are opened.", 1 },
-    { "Sebastian Lackner", "setupapi/tests: Add tests for cabinet name passed to SPFILENOTIFY_FILEEXTRACTED.", 1 },
     { "Sebastian Lackner", "setupapi: Also create HardwareId registry key for display devices.", 1 },
     { "Sebastian Lackner", "setupapi: DelReg should recursively delete registry keys.", 1 },
     { "Sebastian Lackner", "setupapi: Fix CabinetName passed to SPFILENOTIFY_CABINETINFO handler.", 1 },
-    { "Sebastian Lackner", "shcore: Add SetProcessDpiAwareness stub.", 1 },
+    { "Sebastian Lackner", "setupapi/tests: Add tests for cabinet name passed to SPFILENOTIFY_FILEEXTRACTED.", 1 },
     { "Sebastian Lackner", "shcore: Add dll.", 1 },
+    { "Sebastian Lackner", "shcore: Add SetProcessDpiAwareness stub.", 1 },
     { "Sebastian Lackner", "shcore: Add stub for GetProcessDpiAwareness.", 1 },
     { "Sebastian Lackner", "shcore: Implement stub for GetDpiForMonitor.", 1 },
     { "Sebastian Lackner", "shell32: Create Microsoft\\Windows\\Themes directory during Wineprefix creation.", 1 },
     { "Sebastian Lackner", "shell32: Fix length parameter for ZeroMemory.", 1 },
-    { "Sebastian Lackner", "shlwapi/tests: Add additional tests for UrlCombine and UrlCanonicalize.", 1 },
     { "Sebastian Lackner", "shlwapi: SHMapHandle should not set error when NULL is passed as hShared.", 1 },
+    { "Sebastian Lackner", "shlwapi/tests: Add additional tests for UrlCombine and UrlCanonicalize.", 1 },
     { "Sebastian Lackner", "shlwapi: UrlCombineW workaround for relative paths.", 1 },
     { "Sebastian Lackner", "stdole32.tlb: Compile typelib with --oldtlb.", 1 },
     { "Sebastian Lackner", "urlmon/tests: Add test for opening cache file with DELETE access.", 1 },
-    { "Sebastian Lackner", "user.exe16: Don't open code CONTAINING_RECORD.", 1 },
-    { "Sebastian Lackner", "user32/tests: Add tests for clicking through layered window.", 1 },
-    { "Sebastian Lackner", "user32/tests: Add tests for window region of layered windows.", 1 },
     { "Sebastian Lackner", "user32: Avoid unnecessary wineserver calls in PeekMessage/GetMessage.", 1 },
     { "Sebastian Lackner", "user32: Cache the result of GetForegroundWindow.", 1 },
     { "Sebastian Lackner", "user32: Call UpdateWindow() during DIALOG_CreateIndirect.", 1 },
@@ -1658,6 +1655,9 @@
     { "Sebastian Lackner", "user32: Implement CWF_CREATE_ONLY flag for CreateWindowStation.", 1 },
     { "Sebastian Lackner", "user32: Refresh MDI menus when DefMDIChildProc(WM_SETTEXT) is called.", 1 },
     { "Sebastian Lackner", "user32: Return a more reasonable display DeviceID.", 1 },
+    { "Sebastian Lackner", "user32/tests: Add tests for clicking through layered window.", 1 },
+    { "Sebastian Lackner", "user32/tests: Add tests for window region of layered windows.", 1 },
+    { "Sebastian Lackner", "user.exe16: Don't open code CONTAINING_RECORD.", 1 },
     { "Sebastian Lackner", "uxthemegtk: Add export for OpenThemeDataEx.", 1 },
     { "Sebastian Lackner", "uxthemegtk: Correctly render buttons with GTK >= 3.14.0.", 1 },
     { "Sebastian Lackner", "uxthemegtk: Fix some incorrect error codes.", 1 },
@@ -1667,7 +1667,6 @@
     { "Sebastian Lackner", "vulkan: Only convert VkDescriptor{Image,Buffer}Info when type is valid.", 1 },
     { "Sebastian Lackner", "vulkan: Use binary search to lookup function in is_null_func.", 1 },
     { "Sebastian Lackner", "widl: Add --oldtlb switch in usage message.", 1 },
-    { "Sebastian Lackner", "wine.inf: Add a ProfileList\\<UserSID> registry subkey.", 1 },
     { "Sebastian Lackner", "wineboot: Assign a drive serial number during prefix creation/update.", 1 },
     { "Sebastian Lackner", "wineboot: Init system32/drivers/etc/{host,networks,protocol,services}.", 1 },
     { "Sebastian Lackner", "winecfg: Add checkbox to enable/disable HideWineExports registry key.", 1 },
@@ -1678,6 +1677,7 @@
     { "Sebastian Lackner", "wined3d: Silence extremely noisy FIXME in wined3d_texture_add_dirty_region.", 1 },
     { "Sebastian Lackner", "wined3d: Silence repeated wined3d_swapchain_present FIXME.", 1 },
     { "Sebastian Lackner", "winedevice: Avoid invalid memory access when relocation block addresses memory outside of the current page.", 1 },
+    { "Sebastian Lackner", "wine.inf: Add a ProfileList\\<UserSID> registry subkey.", 1 },
     { "Sebastian Lackner", "winelib: Append '(Staging)' at the end of the version string.", 1 },
     { "Sebastian Lackner", "winemenubuilder: Create desktop shortcuts with absolute wine path.", 1 },
     { "Sebastian Lackner", "winepulse.drv: Use a separate mainloop and ctx for pulse_test_connect.", 1 },
@@ -1688,15 +1688,15 @@
     { "Sebastian Lackner", "winhlp32: Workaround a bug in Flex.", 1 },
     { "Sebastian Lackner", "winhttp: Fix handling of Accept headers.", 1 },
     { "Sebastian Lackner", "wintrust/tests: Add some additional tests.", 1 },
-    { "Sebastian Lackner", "ws2_32/tests: Add test for completion notification flags.", 1 },
-    { "Sebastian Lackner", "ws2_32/tests: Hide random test failures in socket tests.", 1 },
-    { "Sebastian Lackner", "ws2_32/tests: Work around an incorrect detection in GCC 7.", 1 },
     { "Sebastian Lackner", "ws2_32: Avoid race-conditions of async WSARecv() operations with write watches.", 2 },
     { "Sebastian Lackner", "ws2_32: Divide values returned by SO_RCVBUF and SO_SNDBUF getsockopt options by two.", 1 },
     { "Sebastian Lackner", "ws2_32: Don't skip completion in AcceptEx.", 1 },
     { "Sebastian Lackner", "ws2_32: Implement returning the proper time with SO_CONNECT_TIME.", 1 },
     { "Sebastian Lackner", "ws2_32: Invalidate client-side file descriptor cache in WSACleanup.", 1 },
     { "Sebastian Lackner", "ws2_32: Reuse old async ws2_async_io structures if possible.", 1 },
+    { "Sebastian Lackner", "ws2_32/tests: Add test for completion notification flags.", 1 },
+    { "Sebastian Lackner", "ws2_32/tests: Hide random test failures in socket tests.", 1 },
+    { "Sebastian Lackner", "ws2_32/tests: Work around an incorrect detection in GCC 7.", 1 },
     { "Sebastian Lackner", "wsdapi: Avoid implicit cast of interface pointer.", 1 },
     { "Sebastian Lackner", "wtsapi32: Improve WTSQueryUserToken stub.", 2 },
     { "Sebastian Lackner", "wtsapi32: Partial implementation of WTSEnumerateProcessesW.", 1 },
Only in /home/gyaru/projects/wine-overwatch: OVERWATCH
diff -ur a/README b/README
--- a/README	2017-07-12 03:17:59.000000000 +0200
+++ b/README	2017-07-17 13:28:50.610747114 +0200
@@ -13,15 +13,12 @@
 
 2. QUICK START
 
-From the top-level directory of the Wine source (which contains this file),
-run:
+Overwatch requires a Shared WoW64 build of wine. Follow the directions at
+(https://wiki.winehq.org/Building_Wine#Shared_WoW64).
 
-./configure
-make
-
-Run programs as "wine program".  For more information and problem
-resolution, read the rest of this file, the Wine man page, and
-especially the wealth of information found at http://www.winehq.org.
+Ubuntu users will need to setup up a 32bit chroot or container,
+instructions to do that are here:
+(https://wiki.winehq.org/Building_Biarch_Wine_On_Ubuntu#Build_64-bit_Wine)
 
 
 3. REQUIREMENTS
diff -ur a/tools/makedep.c b/tools/makedep.c
--- a/tools/makedep.c	2017-07-12 03:17:59.000000000 +0200
+++ b/tools/makedep.c	2017-07-17 13:28:51.434073733 +0200
@@ -2818,7 +2818,33 @@
                               strmake( "p$(dlldir)/%s%s", make->module, dll_ext ));
             add_install_rule( make, install_rules, make->module, strmake( "%s.fake", make->module ),
                               strmake( "d$(fakedlldir)/%s", make->module ));
-            output( "%s%s %s.fake:", module_path, dll_ext, module_path );
+
+            output( "%s.fake: %s%s", module_path, module_path, dll_ext );
+            if (spec_file) output_filename( spec_file );
+            output_filenames_obj_dir( make, object_files );
+            output_filenames_obj_dir( make, res_files );
+            output_filenames( dep_libs );
+            output_filename( tools_path( make, "winebuild" ));
+            output_filename( tools_path( make, "winegcc" ));
+            output( "\n" );
+            output( "\t%s -o $@", tools_path( make, "winegcc" ));
+            output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
+            if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
+            output_filenames( target_flags );
+            output_filenames( unwind_flags );
+            if (spec_file)
+            {
+                output( " -shared %s", spec_file );
+                output_filenames( make->extradllflags );
+            }
+            else output_filenames( make->appmode );
+            output_filenames_obj_dir( make, object_files );
+            output_filenames_obj_dir( make, res_files );
+            output_filenames( all_libs );
+            output_filename( "$(LDFLAGS)" );
+            output( "\n" );
+
+            output( "%s%s:", module_path, dll_ext );
         }
         else
         {
diff -ur a/tools/winebuild/build.h b/tools/winebuild/build.h
--- a/tools/winebuild/build.h	2017-07-12 03:17:59.000000000 +0200
+++ b/tools/winebuild/build.h	2017-07-17 13:28:51.437407039 +0200
@@ -298,7 +298,7 @@
 extern int load_res32_file( const char *name, DLLSPEC *spec );
 extern void output_resources( DLLSPEC *spec );
 extern void output_bin_resources( DLLSPEC *spec, unsigned int start_rva );
-extern void output_fake_module( DLLSPEC *spec );
+extern void output_fake_module( DLLSPEC *spec, const char *native );
 extern void output_def_file( DLLSPEC *spec, int include_private );
 extern void load_res16_file( const char *name, DLLSPEC *spec );
 extern void output_res16_data( DLLSPEC *spec );
@@ -362,6 +362,7 @@
 extern int link_ext_symbols;
 extern int force_pointer_size;
 extern int unwind_tables;
+extern unsigned long image_base;
 
 extern char *input_file_name;
 extern char *spec_file_name;
diff -ur a/tools/winebuild/main.c b/tools/winebuild/main.c
--- a/tools/winebuild/main.c	2017-07-12 03:17:59.000000000 +0200
+++ b/tools/winebuild/main.c	2017-07-17 13:28:51.440740345 +0200
@@ -80,7 +80,9 @@
 FILE *output_file = NULL;
 const char *output_file_name = NULL;
 static const char *output_file_source_name;
+unsigned long image_base = 0;
 static int fake_module;
+static const char *fake_native;
 
 struct strarray lib_path = { 0 };
 struct strarray as_command = { 0 };
@@ -260,9 +262,11 @@
 "   -f FLAGS                  Compiler flags (-fPIC and -fasynchronous-unwind-tables are supported)\n"
 "   -F, --filename=DLLFILE    Set the DLL filename (default: from input file name)\n"
 "       --fake-module         Create a fake binary module\n"
+"       --fake-native=DLLFILE Set the native DLL filename for a fake binary module\n"
 "   -h, --help                Display this help message\n"
 "   -H, --heap=SIZE           Set the heap size for a Win16 dll\n"
 "   -I DIR                    Ignored for C flags compatibility\n"
+"       --image-base=ADDRESS  Set the DLL base address\n"
 "   -k, --kill-at             Kill stdcall decorations in generated .def files\n"
 "   -K, FLAGS                 Compiler flags (only -KPIC is supported)\n"
 "       --large-address-aware Support an address space larger than 2Gb\n"
@@ -300,6 +304,8 @@
     LONG_OPT_CCCMD,
     LONG_OPT_EXTERNAL_SYMS,
     LONG_OPT_FAKE_MODULE,
+    LONG_OPT_FAKE_NATIVE,
+    LONG_OPT_IMAGE_BASE,
     LONG_OPT_LARGE_ADDRESS_AWARE,
     LONG_OPT_LDCMD,
     LONG_OPT_NMCMD,
@@ -322,6 +328,8 @@
     { "cc-cmd",        1, 0, LONG_OPT_CCCMD },
     { "external-symbols", 0, 0, LONG_OPT_EXTERNAL_SYMS },
     { "fake-module",   0, 0, LONG_OPT_FAKE_MODULE },
+    { "fake-native",   1, 0, LONG_OPT_FAKE_NATIVE },
+    { "image-base",    1, 0, LONG_OPT_IMAGE_BASE },
     { "large-address-aware", 0, 0, LONG_OPT_LARGE_ADDRESS_AWARE },
     { "ld-cmd",        1, 0, LONG_OPT_LDCMD },
     { "nm-cmd",        1, 0, LONG_OPT_NMCMD },
@@ -496,6 +504,12 @@
         case LONG_OPT_FAKE_MODULE:
             fake_module = 1;
             break;
+        case LONG_OPT_FAKE_NATIVE:
+            fake_native = xstrdup( optarg );
+            break;
+        case LONG_OPT_IMAGE_BASE:
+            image_base = strtoul( optarg, NULL, 0 );
+            break;
         case LONG_OPT_EXTERNAL_SYMS:
             link_ext_symbols = 1;
             break;
@@ -644,7 +658,7 @@
         if (fake_module)
         {
             if (spec->type == SPEC_WIN16) output_fake_module16( spec );
-            else output_fake_module( spec );
+            else output_fake_module( spec, fake_native );
             break;
         }
         read_undef_symbols( spec, argv );
diff -ur a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
--- a/tools/winebuild/spec32.c	2017-07-12 03:17:59.000000000 +0200
+++ b/tools/winebuild/spec32.c	2017-07-17 13:28:51.440740345 +0200
@@ -46,8 +46,184 @@
 #define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
 #define IMAGE_ROM_OPTIONAL_HDR_MAGIC  0x107
 
+struct export_func
+{
+    const char     *name;
+    unsigned int    name_rva;
+    int             ordinal;
+    unsigned int    va;
+};
+
+struct export
+{
+    struct export_func *exports;
+    int                 nb_exports;
+    int                 max_exports;
+};
+
 int needs_get_pc_thunk = 0;
 
+static inline int needs_syscalls( DLLSPEC *spec )
+{
+    return (target_cpu == CPU_x86_64) &&
+           spec->dll_name && strcmp(spec->dll_name, "ntdll") == 0;
+}
+
+static void add_export_func( struct export *exp, const char *name, int ordinal, unsigned int va )
+{
+    if (exp->nb_exports == exp->max_exports)
+    {
+        exp->max_exports *= 2;
+        if (exp->max_exports < 32) exp->max_exports = 32;
+        exp->exports = xrealloc( exp->exports, exp->max_exports * sizeof(*exp->exports) );
+    }
+    exp->exports[exp->nb_exports].name = name;
+    exp->exports[exp->nb_exports].name_rva = 0;
+    exp->exports[exp->nb_exports].ordinal = ordinal;
+    exp->exports[exp->nb_exports].va = va;
+    exp->nb_exports++;
+}
+
+static struct export *parse_syscall_exports( const char *name )
+{
+    FILE *f;
+    int err, ordinal = 0;
+    const char *prefix = "__wine_spec_syscall_";
+    size_t prefix_len = strlen( prefix );
+    const char *prog = get_nm_command();
+    char *cmd, buffer[1024];
+    struct export *export;
+
+    export = xmalloc( sizeof(*export) );
+    memset( export, 0, sizeof(*export) );
+
+    cmd = strmake( "%s -P -t x %s", prog, name );
+    if (!(f = popen( cmd, "r" )))
+        fatal_error( "Cannot execute '%s'\n", cmd );
+
+    while (fgets( buffer, sizeof(buffer), f ))
+    {
+        char *name;
+        char *p = buffer + strlen(buffer) - 1;
+        unsigned long va;
+        if (p < buffer) continue;
+        if (*p == '\n') *p-- = 0;
+        p = name = buffer;
+        while (*p && *p != ' ') p++;
+        if (*p == 0) continue;
+        *p++ = 0;
+        if (p[0] != 't' || p[1] != ' ') continue;
+        p += 2;
+        va = strtoul( p, NULL, 16 );
+        if (strncmp( name, prefix, prefix_len ) == 0)
+            add_export_func( export, xstrdup(name + prefix_len), ordinal++, va );
+    }
+    if ((err = pclose( f ))) warning( "%s failed with status %d\n", cmd, err );
+    free( cmd );
+
+    return export;
+}
+
+static void output_text_section( DLLSPEC *spec, unsigned int rva, const char *native )
+{
+    static const unsigned char dll_code_section[] = { 0x31, 0xc0,          /* xor %eax,%eax */
+                                                      0xc2, 0x0c, 0x00 };  /* ret $12 */
+
+    static const unsigned char exe_code_section[] = { 0xb8, 0x01, 0x00, 0x00, 0x00,  /* movl $1,%eax */
+                                                      0xc2, 0x04, 0x00 };            /* ret $4 */
+
+    static const unsigned char prefix[] = { 0x0f, 0x1f, 0x44, 0x00, 0x00, /* nop */
+                                            0x68 };                       /* push ... */
+
+    int i;
+    struct export *exp;
+
+    /* attempted to migrate this code to the new multi pass label system ~ gamax92 */
+
+    if (spec->characteristics & IMAGE_FILE_DLL)
+        put_data( dll_code_section, sizeof(dll_code_section) );
+    else
+        put_data( exe_code_section, sizeof(exe_code_section) );
+
+    if (native == NULL)
+        return;
+
+    exp = parse_syscall_exports( native );
+
+    /* export directory header */
+
+    align_output_rva( 32, 32 );
+    put_label( "export_start" );
+    put_dword( 0 ); /* Characteristics */
+    put_dword( 0 ); /* TimeDateStamp */
+    put_dword( 0 ); /* MajorVersion/MinorVersion */
+    put_dword( label_rva("dll_name") ); /* Name */
+    put_dword( 0 ); /* Base */
+    put_dword( exp->nb_exports ); /* NumberOfFunctions */
+    put_dword( exp->nb_exports ); /* NumberOfNames */
+    put_dword( label_rva("export_funcs") ); /* AddressOfFunctions */
+    put_dword( label_rva("export_names") ); /* AddressOfNames */
+    put_dword( label_rva("export_ordinals") ); /* AddressOfNameOrdinals */
+
+    /* function pointers */
+
+    align_output_rva( 4, 4 );
+    put_label( "export_funcs" );
+    for (i = 0; i < exp->nb_exports; i++)
+        put_dword( exp->exports[i].va - image_base );
+
+    /* names */
+
+    put_label( "dll_name" );
+    put_str( spec->file_name );
+    for (i = 0; i < exp->nb_exports; i++)
+    {
+        struct export_func *e = &exp->exports[i];
+        e->name_rva = output_buffer_rva;
+        put_str( e->name );
+    }
+
+    /* name ptrs */
+
+    align_output_rva( 4, 4 );
+    put_label( "export_names" );
+    for (i = 0; i < exp->nb_exports; i++)
+        put_dword( exp->exports[i].name_rva );
+
+    /* ordinals */
+
+    align_output_rva( 4, 4 );
+    put_label( "export_ordinals" );
+    for (i = 0; i < exp->nb_exports; i++)
+        put_word( exp->exports[i].ordinal );
+    align_output_rva( 4, 4 );
+
+    put_label( "export_end" );
+
+    /* fake code */
+
+    for (i = 0; i < exp->nb_exports; i++)
+    {
+        struct export_func *e = &exp->exports[i];
+        unsigned int offset = e->va - image_base - rva + label_pos("text_start");
+
+        if (offset + 16 > output_buffer_size)
+        {
+            output_buffer_size = offset + 16;
+            output_buffer = xrealloc( output_buffer, output_buffer_size );
+        }
+
+        output_buffer_pos = offset;
+        put_data( prefix, sizeof(prefix) );
+        put_dword( e->va );
+        put_byte( 0xc3 ); /* ret */
+    }
+
+	/* correct output_buffer_rva */
+
+	output_buffer_rva = output_buffer_pos - label_pos("text_start") + label_rva("text_start");
+}
+
 /* check if entry point needs a relay thunk */
 static inline int needs_relay( const ORDDEF *odp )
 {
@@ -449,6 +625,11 @@
                 output( "\t%s %s_%s\n",
                          get_asm_ptr_keyword(), asm_name("__wine_spec_ext_link"), odp->link_name );
             }
+            else if (needs_syscalls(spec) && odp->type != TYPE_EXTERN)
+            {
+                /* system calls */
+                output( "\t%s __wine_spec_syscall_%s\n", get_asm_ptr_keyword(), odp->name );
+            }
             else
             {
                 output( "\t%s %s\n", get_asm_ptr_keyword(), asm_name(odp->link_name) );
@@ -512,6 +693,28 @@
     output( "\t.align %d\n", get_alignment(get_ptr_size()) );
     output( ".L__wine_spec_exports_end:\n" );
 
+    /* output syscall wrappers */
+
+    if (needs_syscalls(spec))
+    {
+        output( "\t.text\n" );
+        for (i = spec->base; i <= spec->limit; i++)
+        {
+            ORDDEF *odp = spec->ordinals[i];
+            if (odp && (odp->flags & (FLAG_FORWARD|FLAG_EXT_LINK)) == 0)
+            {
+                if (odp->type != TYPE_STUB && odp->type != TYPE_EXTERN)
+                {
+                    output( "__wine_spec_syscall_%s:\n", odp->name );
+                    output( "\t.byte 0x0f, 0x1f, 0x44, 0x00, 0x00\n" );
+                    output( "\tjmp %s\n", asm_name(odp->link_name) );
+                    output( "\t.byte 0x66, 0x0f, 0x1f, 0x44, 0x00, 0x00\n" );
+                }
+            }
+        }
+        output( "\t.data\n" );
+    }
+
     /* output relays */
 
     if (!has_relays( spec ))
@@ -944,14 +1147,8 @@
  *
  * Helper to create a fake binary module from a spec file.
  */
-static void output_fake_module_pass( DLLSPEC *spec )
+static void output_fake_module_pass( DLLSPEC *spec, const char *native )
 {
-    static const unsigned char dll_code_section[] = { 0x31, 0xc0,          /* xor %eax,%eax */
-                                                      0xc2, 0x0c, 0x00 };  /* ret $12 */
-
-    static const unsigned char exe_code_section[] = { 0xb8, 0x01, 0x00, 0x00, 0x00,  /* movl $1,%eax */
-                                                      0xc2, 0x04, 0x00 };            /* ret $4 */
-
     static const char fakedll_signature[] = "Wine placeholder DLL";
     const unsigned int page_size = get_page_size();
     const unsigned int section_align = page_size;
@@ -1015,7 +1212,8 @@
     put_dword( label_rva("entrypoint") );            /* AddressOfEntryPoint */
     put_dword( label_rva("text_start") );            /* BaseOfCode */
     if (get_ptr_size() == 4) put_dword( label_rva("data_start") ); /* BaseOfData */
-    put_pword( 0x10000000 );                         /* ImageBase */
+    if (image_base) put_pword( image_base );         /* ImageBase */
+    else put_pword( 0x10000000 );
     put_dword( section_align );                      /* SectionAlignment */
     put_dword( file_align );                         /* FileAlignment */
     put_word( 1 );                                   /* MajorOperatingSystemVersion */
@@ -1135,10 +1333,7 @@
     {
         put_label( "text_start" );
         put_label( "entrypoint" );
-        if (spec->characteristics & IMAGE_FILE_DLL)
-            put_data( dll_code_section, sizeof(dll_code_section) );
-        else
-            put_data( exe_code_section, sizeof(exe_code_section) );
+        output_text_section( spec, section_align, native );
         put_label( "text_end" );
     }
 
@@ -1176,18 +1371,18 @@
  *
  * Build a fake binary module from a spec file.
  */
-void output_fake_module( DLLSPEC *spec )
+void output_fake_module( DLLSPEC *spec, const char *native )
 {
     resolve_imports( spec );
 
     /* First pass */
     init_output_buffer();
-    output_fake_module_pass( spec );
+    output_fake_module_pass( spec, native );
 
     /* Second pass */
     output_buffer_pos = 0;
     output_buffer_rva = 0;
-    output_fake_module_pass( spec );
+    output_fake_module_pass( spec, native );
 
     flush_output_buffer();
 }
